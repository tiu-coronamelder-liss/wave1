---
title: "CoronaMelder rapportage"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "11/11/2020"
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls()) #Clear workspace

# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# For analysis and data preprocessing
library(psy) # psy for the cronbach function

# Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

# Palettes
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]

# Custom kleurtjes -- we lenen zwart uit 'RdGy' voor "ik ben niet van plan de coronamelder te gebruiken",
# dan van oranje naar groen voor de overige opties (oneens -> eens):
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])

# Creating new variables
## Health literacy
# To enable a median split, labels are first recoded to numbers 
data$HealthLiteracy1n = recode(data$HealthLiteracy1, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)
data$HealthLiteracy2n = recode(data$HealthLiteracy2, 'Helemaal niet'=1, 'Een klein beetje'=2, 'Een beetje'=3, 'Nogal'=4,  'Heel erg'=5)
data$HealthLiteracy3n = recode(data$HealthLiteracy3, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)

# Since items HealtLiteracy1 and 3 are negatively phrased they will be reverse coded such that higher numbers refer to higher health literacy
data$HealthLiteracy1nr = recode(data$HealthLiteracy1n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 
data$HealthLiteracy3nr = recode(data$HealthLiteracy3n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 

# Calculate construct and cronbach alpha (0.58 - poor). The reliability of the scale is low and based on the histogram the distribution is highly skewed; no further analysis of this variable will be done. 
data$HealthLiteracy <- rowMeans(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")], na.rm = TRUE)
cronbach(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")])
#hl_avg <- mean(data$HealthLiteracy)
#hist(data$HealthLiteracy)
# Data splitsen hoge vs. midden. vs lage health literacy
#data$CatHL <- cut(data$HealthLiteracy, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

```
\newpage
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
## Methode {.unlisted .unnumbered}
## Resultaten {.unlisted .unnumbered}
## Conclusie {.unlisted .unnumbered}
## Aanbevelingen {.unlisted .unnumbered}
\newpage
# Achtergrond
Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.
\newpage
# Methoden
## Onderzoeksopzet
In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen zullen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invullen via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen € 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk standaard bijna een maand duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 1 
Steekproef: Een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst ‘Health’ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  

Responsoverzicht | 
------------- | -------------
Selectie aantal leden huishouden: | 2.093 (100,0%)  
Nonrespons | 183 (8,7%)  
Respons | 1.910 (91,3%)  
  Compleet | 1.900 (90,8%)  
  Incompleet | 10 (0,5%)  

Datum van dataverzameling: 19 oktober 2020 – 1 november 2020.

In de resultaten sectie worden de uitkomsten getoond van de 1900 respondenten waarbij de data compleet was. In appendix X kan een vergelijking van de demografische samenstelling steekproef in vergelijking met die van de Nederlandse bevolking gevonden worden. 
\newpage
# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren

```{r demographics, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ages <- table(data$lftdcat)
pl <- barplot(ages, main="Leeftijdscategorieën van respondenten", xaxt="n")
labs <- paste(names(table(data$lftdcat)))
text(cex=0.8, x=pl+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)
```

### Gezondheidsmotivatie en risicoperceptie corona besmetting
#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
#### Corona risicoperceptie en ernst
```{r PSus, echo=FALSE}
# Dataframe voor susceptibility + antwoordopties terugzetten
df_PSus <- data %>% gather("PSus", "value", contains("HBM_PSus_self1"), contains("HBM_PSus_other2"))
df_PSus <- mutate(df_PSus, value = factor(value, levels=rev(levels(data$HBM_PSus_self1))))

# Plot susceptibility self / others
ggplot(data=df_PSus, aes(fill=value, x=PSus)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=c("Als ik zelf besmet raak\n is de kans groot dat\n ik anderen besmet", "Er is een grote kans\n dat ik in de komende\n 2 maanden besmet raak")) + ggtitle("Waargenomen vatbaarheid voor het Coronavirus")

```

```{r Psev, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst van het Coronavirus"}
# Dataframe voor severity + antwoordopties terugzetten
df_PSev <- data %>% gather("PSev", "value", contains("HBM_PSev_self1"), contains("HBM_PSev_other2"))
df_PSev <- mutate(df_PSev, value = factor(value, levels=rev(levels(data$HBM_PSev_self1))))

# Plot severity self / others
ggplot(data=df_PSev, aes(fill=value, x=PSev)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=c("Ik vind het erg als ik\n andere mensen besmet", "Ik vind het erg om\n besmet te raken")) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

#### Naleven algemene gedragsregels
#### Intentie tot naleving algemene gedragsregels

### Algemene opvattingen over het coronavirus
#### Complottheorieën
#### Vertrouwen in aanpak van de overheid


## Bekendheid en gebruik
### Bekendheid met CoronaMelder

```{r awarenessleeftijd, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Dit is even een test voor grafiek zonder ggplot, laat het even staan als voorbeeld.
aware <- table(data$Awareness)
plotaware <- barplot(aware, main="Bekendheid met CoronaMelder", xaxt="n")
labs <- paste(names(table(data$Awareness)))
text(cex=0.8, x=plotaware+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)

# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE}
# Awareness op gender
ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### Gebruik en intentie tot gebruik CoronaMelder

```{r Intentie hele sample, echo=FALSE}
###Intentie gesplitst op wel + niet gebruik

# Dataframe voor intentie + antwoordopties terugzetten
df_intentie <- data %>% gather("intentie", "value", contains("BI1a_UTAUT"), contains("BI1b_UTAUT"))
df_intentie <- mutate(df_intentie, value = factor(value, levels=rev(levels(data$BI1a_UTAUT))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_intentie, aes(fill=value, x=intentie)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + scale_x_discrete(labels=c("Niet-gebruiker", "Gebruiker")) + labs(x = "", y = "", fill = "") + ggtitle("Intenties gesplitst op huidig gebruik") + scale_fill_manual(values=my_palette7)
```


```{r Intentie gesplitst op HL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
#df_PSev %>% filter(!is.na(Value))

data_nona1a <- data[!is.na(data$BI1a_UTAUT),]
data_nona1b <- data[!is.na(data$BI1b_UTAUT),]

#ggplot(data=data_nona1a, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
#ggplot(data=data_nona1b, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

rm(data_nona1a)
rm(data_nona1b)
```


## Verklarende variabelen voor adoptie
### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
### Vertrouwen in adequaatheid techniek
### Maatschappelijke gevolgen gebruik CoronaMelder
### Verwachte gebruiksvriendelijkheid en zelfeffectiviteit

```{r UTAUT_PE, echo=FALSE}
# Dataframe maken voor Perceived Expectancy + antwoordopties terugzetten
df_utaut_pe <- data %>% gather("UTAUT_PE", "value", contains("PE1_UTAUT"), contains("PE2_UTAUT"))
df_utaut_pe <- mutate(df_utaut_pe, value = factor(value, levels=rev(levels(data$PE1_UTAUT))))

# Custom kleurtjes
# van oranje naar groen voor de overige opties (oneens -> eens):
# Grafiek uitdraaien
ggplot(data=df_utaut_pe, aes(fill=value, x=UTAUT_PE)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) +  scale_y_continuous(labels=percent) + labs(x = "", y = "", fill = "") + scale_x_discrete(labels=c("Door de CoronaMelder app\n te gebruiken help ik mee\n bij de bestrijding van het\n coronavirus", "De CoronaMelder app is\n nuttig om ervoor te zorgen\n dat het coronavirus zich\n minder verspreidt")) + coord_flip() + scale_fill_manual(values=my_palette7)
```

### Technologie gerelateerde belemmeringen
### Persoonlijke nadelen van gebruik en verplichting tot gebruik
### Affectieve reacties
### Sociale invloeden
### Privacy en dataveiligheid 
## Effecten
### Meldingen en reacties op adviezen gegeven in de melding
#### Ontvangen meldingen en opvolging van de adviezen
#### Intentie tot opvolgen adviezen gegeven in de melding
##### Bij aanwezigheid symptomen die passen bij een besmetting met het coronavirus
##### Bij afwezigheid symptomen die passen bij een besmetting met het coronavirus
#### Verklarende factoren opvolging adviezen gegeven in melding
##### Eigen effectiviteit opvolging adviezen
##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen
### Intentie tot doorgeven codes na positieve test
### Onbeoogde effecten: schijnveiligheid
\newpage
# Conclusie en aanbevelingen
\newpage
# Referenties
\newpage
# Bijlagen
## Vragenlijst wave 1












## Meldingen en reacties op adviezen gegeven in de melding

### Ontvangen meldingen en opvolging adviezen
```{r meldingen, echo=FALSE}
# Om onderstaande tekst wat duidelijker te maken zouden we ook hier variabelen kunnen aanmaken, en alleen die in de tekst terug laten komen, bv.
num_users <- nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# NB: hieronder doe ik een ingewikkelde filter over het krijgen van een melding, die is eigenlijk ook te doen met simpelweg notifications_1 == 'Ja', maar ik wilde even complexe filters demonstreren ;)
```

Van de `r nrow(data)` deelnemers, hadden er `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))` de app geïnstalleerd, en `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))` hadden hem nu niet meer geïnstalleerd, maar wel gehad. In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app.

# Bekendheid met Coronamelder [vooral om te proberen]
### Bekendheid_Splitsing leeftijd



# Bekendheid_Splitsing geslacht






###Performance expectancy



# Overige analyses

## Opvolging van advies om je te laten testen

``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

Zoals te zien in figuur \@ref(fig:adherence), gebeuren er interessante dingen.


## Test
``` {r tabtest, echo=FALSE, tab.cap="Jan is hier"}
# Na wat onderzoek op internet heb ik ontdekt dat de "flextable" package het beste te gebruiken is als we naar Word willen exporteren, vandaar dat ik nu voor deze ben gegaan :)

# Ik denk dat de beste manier is om gewoon een dataframe te maken die al juist ingericht is,
# in plaats van allerlei berekeningen binnen de tabel te moeten doen (zoals counts en groeperen)...
# Deze hieronder lijkt te werken, maar ik weet niet hoe stabiel die 'x' kolom is, en of die altijd gelijk gaat zijn aan 'x.1' in dit geval -- in de gaten houden :)
testframe <- data.frame(plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresSymptoms_Test']), plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresNosymptoms_Test']))

ft <- flextable(
  head(testframe, n = nrow(testframe)),
  col_keys = c("x", "freq", "freq.1")
)

ft <- set_header_labels(ft, values = list(x = "", freq = "Wel symptomen", freq.1 = "Geen symptomen"))

# Percentages toevoegen
ft <- compose(ft, j = "freq", value = as_paragraph(freq, " (", sprintf("%.2f", freq/sum(freq)*100), "%)"))
ft <- compose(ft, j = "freq.1", value = as_paragraph(freq.1, " (", sprintf("%.2f", freq.1/sum(freq.1)*100), "%)"))

# Totalen
bla <- as_paragraph(sum(testframe$freq), " (100%)")
ft <- add_footer_row(ft, values = c("Totaal", paste(sum(testframe$freq), " (100%)"), paste(sum(testframe$freq.1), " (100%)")), colwidths = c(1,1,1))#as_paragraph(sum(freq), " (100%)"), as_paragraph(sum(freq.1), " (100%)")))
ft <- fontsize(ft, size = 11, part = "footer")
ft <- align(ft, j = 2:3, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

ft <- autofit(ft)

ft

```