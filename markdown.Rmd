---
title: "CoronaMelder rapportage"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "11/11/2020"
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

rm(list = ls()) #Clear workspace

# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# For analysis and data preprocessing
library(psy) # psy for the cronbach function
library(reshape2) # For converting from wide to long format (function: melt)

# Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

# Palettes
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]

# Custom kleurtjes -- we lenen zwart uit 'RdGy' voor "ik ben niet van plan de coronamelder te gebruiken",
# dan van oranje naar groen voor de overige opties (oneens -> eens):
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])

# Creating new variables
## Health literacy
# To enable a median split, labels are first recoded to numbers 
data$HealthLiteracy1n = recode(data$HealthLiteracy1, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)
data$HealthLiteracy2n = recode(data$HealthLiteracy2, 'Helemaal niet'=1, 'Een klein beetje'=2, 'Een beetje'=3, 'Nogal'=4,  'Heel erg'=5)
data$HealthLiteracy3n = recode(data$HealthLiteracy3, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)

# Since items HealtLiteracy1 and 3 are negatively phrased they will be reverse coded such that higher numbers refer to higher health literacy
data$HealthLiteracy1nr = recode(data$HealthLiteracy1n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 
data$HealthLiteracy3nr = recode(data$HealthLiteracy3n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 

# Calculate construct and cronbach alpha (0.58 - poor). The reliability of the scale is low and based on the histogram the distribution is highly skewed; no further analysis of this variable will be done. 
data$HealthLiteracy <- rowMeans(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")], na.rm = TRUE)
cronbach(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")])
#hl_avg <- mean(data$HealthLiteracy)
#hist(data$HealthLiteracy)
# Data splitsen hoge vs. midden. vs lage health literacy
#data$CatHL <- cut(data$HealthLiteracy, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

```
\newpage
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
## Methode {.unlisted .unnumbered}
## Resultaten {.unlisted .unnumbered}
## Conclusie {.unlisted .unnumbered}
## Aanbevelingen {.unlisted .unnumbered}
\newpage
# Achtergrond
Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.
\newpage
# Methoden
## Onderzoeksopzet
In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen zullen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invullen via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen € 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk standaard bijna een maand duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 1 
Steekproef: Een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst ‘Health’ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  

Responsoverzicht | 
------------- | -------------
Selectie aantal leden huishouden: | 2.093 (100,0%)  
Nonrespons | 183 (8,7%)  
Respons | 1.910 (91,3%)  
  Compleet | 1.900 (90,8%)  
  Incompleet | 10 (0,5%)  

Datum van dataverzameling: 19 oktober 2020 – 1 november 2020.

In de resultaten sectie worden de uitkomsten getoond van de 1900 respondenten waarbij de data compleet was. In appendix X kan een vergelijking van de demografische samenstelling steekproef in vergelijking met die van de Nederlandse bevolking gevonden worden. 


\newpage

# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren


Geslacht
Lftdcat
sted
belbezig
oplmet
DS_mobile
HealthLiteracy
Riskgroup_contact



```{r demographics, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ages <- table(data$lftdcat)
pl <- barplot(ages, main="Leeftijdscategorieën van respondenten", xaxt="n")
labs <- paste(names(table(data$lftdcat)))
text(cex=0.8, x=pl+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)
```

### Gezondheidsmotivatie en risicoperceptie corona besmetting

CoronaInfectionSelf
CoronaInfectionSelfTest
CoronaInfectionSelfTest_1
CoronaInfectionSelfTest_2
CoronaInfectionOther_1-8


#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
#### Corona risicoperceptie en ernst

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende \n twee maanden risico op een \n besmetting met het coronavirus", 
                         "Als ik besmet raak \n is de kans  groot dat ik anderen \n zal besmetten", 
                         "Ik vind het erg om \n besmet te raken", 
                         "Ik vind het erg als ik \n andere mensen besmet"); 

# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

HBM_PSus_self1
HBM_PSus_self2
HBM_PSus_other2
HBM_PSev_self1
HBM_PSev_self2
HBM_PSev_other2

#### Naleven algemene gedragsregels

Behavior_AdherenceGeneralMeasures_distance
Behavior_AdherenceGeneralMeasures_avoidbusyplaces
Behavior_AdherenceGeneralMeasures_quarantaine
Corona_complaints + Behavior_AdherenceGeneralMeasures_quarantaine


#### Intentie tot naleving algemene gedragsregels

Intention_AdherenceGeneralMeasures_handwashing
Intention_AdherenceGeneralMeasures_distance
Intention_AdherenceGeneralMeasures_avoidbusyplaces
Intention_AdherenceGeneralMeasures_quarantaine


### Algemene opvattingen over het coronavirus


#### Complottheorieën

Beliefs_Conspiracy1
Beliefs_Conspiracy2

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof in complottheorien"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een \n biologisch wapen dat in een \n laboratorium is gemaakt", 
                         "De uitbraak van het \n coronavirus heeft te maken met \n (de aanleg van) het 5G netwerk"); 

# Hier nog wijzigen naar waar/niet waar coding
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

#### Vertrouwen in aanpak van de overheid

Beliefs_TrustGovernment

## Bekendheid en gebruik
### Bekendheid met CoronaMelder

```{r awarenessleeftijd, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Dit is even een test voor grafiek zonder ggplot, laat het even staan als voorbeeld.
aware <- table(data$Awareness)
plotaware <- barplot(aware, main="Bekendheid met CoronaMelder", xaxt="n")
labs <- paste(names(table(data$Awareness)))
text(cex=0.8, x=plotaware+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)

# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE}
# Awareness op gender
ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### Gebruik en intentie tot gebruik CoronaMelder

```{r Intentie hele sample, echo=FALSE}
###Intentie gesplitst op wel + niet gebruik

# Dataframe voor intentie + antwoordopties terugzetten
df_intentie <- data %>% gather("intentie", "value", contains("BI1a_UTAUT"), contains("BI1b_UTAUT"))
df_intentie <- mutate(df_intentie, value = factor(value, levels=rev(levels(data$BI1a_UTAUT))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_intentie, aes(fill=value, x=intentie)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + scale_x_discrete(labels=c("Niet-gebruiker", "Gebruiker")) + labs(x = "", y = "", fill = "") + ggtitle("Intenties gesplitst op huidig gebruik") + scale_fill_manual(values=my_palette7)
```


```{r Intentie gesplitst op HL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
#df_PSev %>% filter(!is.na(Value))

data_nona1a <- data[!is.na(data$BI1a_UTAUT),]
data_nona1b <- data[!is.na(data$BI1b_UTAUT),]

#ggplot(data=data_nona1a, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
#ggplot(data=data_nona1b, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

rm(data_nona1a)
rm(data_nona1b)
```

Opsplitsing Gedrag en intentie (2.2.2):   
1) Vergelijking gebruikers vs niet gebruikers (deze wave laten we de groep die het gebruikt hebben maar nu niet meer buiten beschouwing agz dat er nog vrij weinig zijn)  
2) Van de niet gebruikers: vergelijking van intentie eens (beetjemee eens + eens + helemaal mee eens), neutraal, oneens (beetje mee oneens + eens + helemaal oneens).   
--> Vergelijk deze groepen op alle variabelen in:   
Demografische factoren, gezondheidsmotivatie en algemene opvattingen over het coronavirus (variabelen 2.1).   
Deze opsplitsing naar demografie geeft inzicht in welke groepen vd bevolking de CoronaMelder meer of minder gebruikt wordt. De opsplitsing naar adherence en intentie tot adherence aan de andere maatregelen geeft inzicht in of de gebruikers van de CoronaMelder mensen zijn die zich sowieso al meer aan de maatregelen houden.


## Verklarende variabelen voor adoptie

Opspliting verklarende variabelen (alle subsectie 2.3): 
Allemaal opsplitsen naar 1) gebruikers vs niet gebruikers en 2) Van de niet gebruikers: vergelijking van eens, neutraal, oneens. In zijn totaliteit geeft deze sectie dan een beeld van wat de gebruikers onderscheid van de niet gebruikers, en welke beliefs veranderd kunnen worden bij de groep die de CoronaMelder niet gebruikt maar er neutraal tegenover staat (obv deze verklarende variabelen)


### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus

PE1_UTAUT
PE2_UTAUT

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verwachte effeciviteit CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT")
graph_questionlabels = c("Door de CoronaMelder app te \n gebruiken help ik mee bij de \n bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig \n om ervoor te zorgen dat het \n coronavirus zich minder verspreidt"); 

# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

Beliefs_ResponseefficasyOther
Beliefs_Protectriskgroups




### Vertrouwen in adequaatheid techniek

Beliefs_technologyperformance

### Maatschappelijke gevolgen gebruik CoronaMelder

Beliefs_benefiteconomic

### Verwachte gebruiksvriendelijkheid en zelfeffectiviteit

EE1a_UTAUT
EE2a_UTAUT
EE1b_UTAUT
EE2b_UTAUT
HBM_selfefficacy_CoronaMelder



```{r UTAUT_PE, echo=FALSE}
# Dataframe maken voor Perceived Expectancy + antwoordopties terugzetten
df_utaut_pe <- data %>% gather("UTAUT_PE", "value", contains("PE1_UTAUT"), contains("PE2_UTAUT"))
df_utaut_pe <- mutate(df_utaut_pe, value = factor(value, levels=rev(levels(data$PE1_UTAUT))))

# Custom kleurtjes
# van oranje naar groen voor de overige opties (oneens -> eens):
# Grafiek uitdraaien
ggplot(data=df_utaut_pe, aes(fill=value, x=UTAUT_PE)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) +  scale_y_continuous(labels=percent) + labs(x = "", y = "", fill = "") + scale_x_discrete(labels=c("Door de CoronaMelder app\n te gebruiken help ik mee\n bij de bestrijding van het\n coronavirus", "De CoronaMelder app is\n nuttig om ervoor te zorgen\n dat het coronavirus zich\n minder verspreidt")) + coord_flip() + scale_fill_manual(values=my_palette7)
```

### Technologie gerelateerde belemmeringen

FC1_UTAUT
FC2_UTAUT


### Persoonlijke nadelen van gebruik en verplichting tot gebruik

HBM_ barriers _CoronaMelder 
Beliefs_voluntariness


### Affectieve reacties

Beliefs_fear
Beliefs_notificationfear



### Sociale invloeden


Beliefs_AppAdoption
SI1_UTAUT
SI2_UTAUT
Beliefs_civicduty


### Privacy en dataveiligheid 

Beliefs_datasafety
Beliefs_locationmonitoring
Beliefs_identitymonitoring


## Effecten
### Meldingen en reacties op adviezen gegeven in de melding

notifications_1: hoeveel hebben 1 keer of meerdere keren een melding gehad?
Van degenen die een of meerder meldingen hebben gehad:in welke mate rapporteren ze zich aan de adviezen te houden? 
notification_behavior_quarantaine
Notification_behavior_test
Notification_symptoms


#### Ontvangen meldingen en opvolging van de adviezen
#### Intentie tot opvolgen adviezen gegeven in de melding

 

AdherenceNotificationMeasuresSymptoms_Test
AdherenceNotificationMeasuresSymptoms_Quarantaine
AdherenceNotificationMeasuresSymptoms_Visits
AdherenceNotificationMeasuresSymptoms_CallGP
AdherenceNotificationMeasuresNosymptoms_Test
AdherenceNotificationMeasuresNosymptoms_Quarantaine
AdherenceNotificationMeasuresNoSymptoms_Visits
AdherenceNotificationMeasuresNosymptoms_CallGP  


Opsplitsing intentie tot opvolgen adviezen gegeven in melding: 2.4.1.2.   
Demografische factoren, gezondheidsmotivatie en algemene opvattingen over het coronavirus 


#### Verklarende factoren opvolging adviezen gegeven in melding
##### Eigen effectiviteit opvolging adviezen
HBM_ selfefficacy _Test
HBM_ selfefficacy _Quarantaine
HBM_ selfefficacy _Visits
HBM_ selfefficacy _GP


##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen

HBM_ benefits _Test
HBM_ benefits _Quarantaine
HBM_ benefits _Visits
HBM_ benefits _GP

HBM_ barriers _Test
HBM_ barriers _Quarantaine
HBM_ barriers _Visits
HBM_ barriers _GP




### Intentie tot doorgeven GGD-sleutel na positieve test

Intention_reportinfection

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot doorgeven GGD-sleutel"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, \n ben ik van plan om dit door\n  te geven via de CoronaMelder app"); 

# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)
View(data_graph_longformat)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


```





### Onbeoogde effecten: schijnveiligheid

Beliefs_falsesecurity1
Beliefs_falsesecurity2  


Opsplitsing Onbeoogde effecten: schijnveiligheid 2.4.3: naar Demografische factoren  

\newpage
# Conclusie en aanbevelingen
\newpage
# Referenties
\newpage
# Bijlagen
## Vragenlijst wave 1












## Meldingen en reacties op adviezen gegeven in de melding

### Ontvangen meldingen en opvolging adviezen
```{r meldingen, echo=FALSE}
# Om onderstaande tekst wat duidelijker te maken zouden we ook hier variabelen kunnen aanmaken, en alleen die in de tekst terug laten komen, bv.
num_users <- nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# NB: hieronder doe ik een ingewikkelde filter over het krijgen van een melding, die is eigenlijk ook te doen met simpelweg notifications_1 == 'Ja', maar ik wilde even complexe filters demonstreren ;)
```

Van de `r nrow(data)` deelnemers, hadden er `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))` de app geïnstalleerd, en `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))` hadden hem nu niet meer geïnstalleerd, maar wel gehad. In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app.

# Bekendheid met Coronamelder [vooral om te proberen]
### Bekendheid_Splitsing leeftijd



# Bekendheid_Splitsing geslacht






###Performance expectancy



# Overige analyses

## Opvolging van advies om je te laten testen

``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

Zoals te zien in figuur \@ref(fig:adherence), gebeuren er interessante dingen.


## Test
``` {r tabtest, echo=FALSE, tab.cap="Jan is hier"}
# Na wat onderzoek op internet heb ik ontdekt dat de "flextable" package het beste te gebruiken is als we naar Word willen exporteren, vandaar dat ik nu voor deze ben gegaan :)

# Ik denk dat de beste manier is om gewoon een dataframe te maken die al juist ingericht is,
# in plaats van allerlei berekeningen binnen de tabel te moeten doen (zoals counts en groeperen)...
# Deze hieronder lijkt te werken, maar ik weet niet hoe stabiel die 'x' kolom is, en of die altijd gelijk gaat zijn aan 'x.1' in dit geval -- in de gaten houden :)
testframe <- data.frame(plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresSymptoms_Test']), plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresNosymptoms_Test']))

ft <- flextable(
  head(testframe, n = nrow(testframe)),
  col_keys = c("x", "freq", "freq.1")
)

ft <- set_header_labels(ft, values = list(x = "", freq = "Wel symptomen", freq.1 = "Geen symptomen"))

# Percentages toevoegen
ft <- compose(ft, j = "freq", value = as_paragraph(freq, " (", sprintf("%.2f", freq/sum(freq)*100), "%)"))
ft <- compose(ft, j = "freq.1", value = as_paragraph(freq.1, " (", sprintf("%.2f", freq.1/sum(freq.1)*100), "%)"))

# Totalen
bla <- as_paragraph(sum(testframe$freq), " (100%)")
ft <- add_footer_row(ft, values = c("Totaal", paste(sum(testframe$freq), " (100%)"), paste(sum(testframe$freq.1), " (100%)")), colwidths = c(1,1,1))#as_paragraph(sum(freq), " (100%)"), as_paragraph(sum(freq.1), " (100%)")))
ft <- fontsize(ft, size = 11, part = "footer")
ft <- align(ft, j = 2:3, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

ft <- autofit(ft)

ft

```