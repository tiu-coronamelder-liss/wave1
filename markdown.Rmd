---
title: "CoronaMelder rapportage"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "11/11/2020"
output: 
  bookdown::word_document2:
    reference_docx: markdown_template.docx
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

# Palettes
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]

# Custom kleurtjes -- we lenen zwart uit 'RdGy' voor "ik ben niet van plan de coronamelder te gebruiken",
# dan van oranje naar groen voor de overige opties (oneens -> eens):
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])

# Creating new variables
## Health literacy
#Average health literacy
hl_scale <- rowMeans(sapply(data[, c("HealthLiteracy1", "HealthLiteracy2", "HealthLiteracy3")], as.numeric), na.rm = TRUE)
hl_avg <- mean(hl_scale)

#Data splitsen hoge vs. midden. vs lage health literacy
CatHL <- cut(hl_scale, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

```

# 1 Achtergrond
# 2 Methoden
# 3 Resultaten
## 3.1 Karakteristieken van de steekproef
### 3.1.1 Demografische factoren

```{r demographics, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ages <- table(data$lftdcat)
pl <- barplot(ages, main="Leeftijdscategorieën van respondenten", xaxt="n")
labs <- paste(names(table(data$lftdcat)))
text(cex=0.8, x=pl+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)
```

### 3.1.2 Gezondheidsmotivatie en risicoperceptie corona besmetting

```{r PSus, echo=FALSE}
# Dataframe voor susceptibility + antwoordopties terugzetten
df_PSus <- data %>% gather("PSus", "value", contains("HBM_PSus_self1"), contains("HBM_PSus_other2"))
df_PSus <- mutate(df_PSus, value = factor(value, levels=rev(levels(data$HBM_PSus_self1))))

# Plot susceptibility self / others
ggplot(data=df_PSus, aes(fill=value, x=PSus)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + scale_x_discrete(labels=c("Als ik zelf besmet raak\n is de kans groot dat\n ik anderen besmet", "Er is een grote kans\n dat ik in de komende\n 2 maanden besmet raak")) + ggtitle("Waargenomen vatbaarheid voor het Coronavirus")

```

```{r Psev, echo=FALSE, fig.width=7}
# Dataframe voor severity + antwoordopties terugzetten
df_PSev <- data %>% gather("PSev", "value", contains("HBM_PSev_self1"), contains("HBM_PSev_other2"))
df_PSev <- mutate(df_PSev, value = factor(value, levels=rev(levels(data$HBM_PSev_self1))))

# Plot severity self / others
ggplot(data=df_PSev, aes(fill=value, x=PSev)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette7) + ggtitle("Waargenomen ernst van het Coronavirus") + scale_x_discrete(labels=c("Ik vind het erg als ik\n andere mensen besmet", "Ik vind het erg om\n besmet te raken")) + ggtitle("Waargenomen ernst van het Coronavirus")

```

### 3.1.3 Algemene opvattingen over het coronavirus



## 3.2 Bekendheid en gebruik
### 3.2.1 Bekendheid met CoronaMelder

```{r awarenessleeftijd, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
#Dit is even een test voor grafiek zonder ggplot, laat het even staan als voorbeeld.
aware <- table(data$Awareness)
plotaware <- barplot(aware, main="Bekendheid met CoronaMelder", xaxt="n")
labs <- paste(names(table(data$Awareness)))
text(cex=0.8, x=plotaware+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)

# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE}
# Awareness op gender
ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### 3.2.2 Gebruik en intentie tot gebruik CoronaMelder

```{r Intentie hele sample, echo=FALSE}
###Intentie gesplitst op wel + niet gebruik

# Dataframe voor intentie + antwoordopties terugzetten
df_intentie <- data %>% gather("intentie", "value", contains("BI1a_UTAUT"), contains("BI1b_UTAUT"))
df_intentie <- mutate(df_intentie, value = factor(value, levels=rev(levels(data$BI1a_UTAUT))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_intentie, aes(fill=value, x=intentie)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + coord_flip() + scale_x_discrete(labels=c("Niet-gebruiker", "Gebruiker")) + labs(x = "", y = "", fill = "") + ggtitle("Intenties gesplitst op huidig gebruik") + scale_fill_manual(values=my_palette7)
```


```{r Intentie gesplitst op HL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
ggplot(data=data, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
ggplot(data=data, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))
```


## 3.3 Verklarende variabelen voor adoptie
### 3.3.1 Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
### 3.3.2 Vertrouwen in adequaatheid techniek
### 3.3.3 Maatschappelijke gevolgen gebruik CoronaMelder
### 3.3.4 Verwachte gebruiksvriendelijkheid en zelfeffectiviteit

```{r UTAUT_PE, echo=FALSE}
# Dataframe maken voor Perceived Expectancy + antwoordopties terugzetten
df_utaut_pe <- data %>% gather("UTAUT_PE", "value", contains("PE1_UTAUT"), contains("PE2_UTAUT"))
df_utaut_pe <- mutate(df_utaut_pe, value = factor(value, levels=rev(levels(data$PE1_UTAUT))))

# Custom kleurtjes
# van oranje naar groen voor de overige opties (oneens -> eens):
# Grafiek uitdraaien
ggplot(data=df_utaut_pe, aes(fill=value, x=UTAUT_PE)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) +  scale_y_continuous(labels=percent) + labs(x = "", y = "", fill = "") + scale_x_discrete(labels=c("Door de CoronaMelder app\n te gebruiken help ik mee\n bij de bestrijding van het\n coronavirus", "De CoronaMelder app is\n nuttig om ervoor te zorgen\n dat het coronavirus zich\n minder verspreidt")) + coord_flip() + scale_fill_manual(values=my_palette7)
```

### 3.3.5 Technologie gerelateerde belemmeringen
### 3.3.6 Persoonlijke nadelen van gebruik en verplichting tot gebruik
### 3.3.7 Affectieve reacties
### 3.3.8 Sociale invloeden
### 3.3.9 Privacy en dataveiligheid 
## 3.4 Effecten
### 3.4.1 Meldingen en reacties op adviezen gegeven in de melding
### 3.4.2 Intentie tot doorgeven codes na positieve test
### 2.4.3 Onbeoogde effecten: schijnveiligheid
# 4 Conclusie en aanbevelingen
# 5 Referenties
# 6 Bijlagen
## 6.1 Vragenlijst wave 1












## Meldingen en reacties op adviezen gegeven in de melding

### Ontvangen meldingen en opvolging adviezen
```{r meldingen, echo=FALSE}
# Om onderstaande tekst wat duidelijker te maken zouden we ook hier variabelen kunnen aanmaken, en alleen die in de tekst terug laten komen, bv.
num_users <- nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# NB: hieronder doe ik een ingewikkelde filter over het krijgen van een melding, die is eigenlijk ook te doen met simpelweg notifications_1 == 'Ja', maar ik wilde even complexe filters demonstreren ;)
```

Van de `r nrow(data)` deelnemers, hadden er `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))` de app geïnstalleerd, en `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))` hadden hem nu niet meer geïnstalleerd, maar wel gehad. In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app.

# Bekendheid met Coronamelder [vooral om te proberen]
### Bekendheid_Splitsing leeftijd



# Bekendheid_Splitsing geslacht






###Performance expectancy



# Overige analyses

## Opvolging van advies om je te laten testen

``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

Zoals te zien in figuur \@ref(fig:adherence), gebeuren er interessante dingen.


## Test
``` {r tabtest, echo=FALSE, tab.cap="Jan is hier"}
# Na wat onderzoek op internet heb ik ontdekt dat de "flextable" package het beste te gebruiken is als we naar Word willen exporteren, vandaar dat ik nu voor deze ben gegaan :)

# Ik denk dat de beste manier is om gewoon een dataframe te maken die al juist ingericht is,
# in plaats van allerlei berekeningen binnen de tabel te moeten doen (zoals counts en groeperen)...
# Deze hieronder lijkt te werken, maar ik weet niet hoe stabiel die 'x' kolom is, en of die altijd gelijk gaat zijn aan 'x.1' in dit geval -- in de gaten houden :)
testframe <- data.frame(plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresSymptoms_Test']), plyr::count(df_adherence$Value[df_adherence$Symptoms == 'AdherenceNotificationMeasuresNosymptoms_Test']))

ft <- flextable(
  head(testframe, n = nrow(testframe)),
  col_keys = c("x", "freq", "freq.1")
)

ft <- set_header_labels(ft, values = list(x = "", freq = "Wel symptomen", freq.1 = "Geen symptomen"))

# Percentages toevoegen
ft <- compose(ft, j = "freq", value = as_paragraph(freq, " (", sprintf("%.2f", freq/sum(freq)*100), "%)"))
ft <- compose(ft, j = "freq.1", value = as_paragraph(freq.1, " (", sprintf("%.2f", freq.1/sum(freq.1)*100), "%)"))

# Totalen
bla <- as_paragraph(sum(testframe$freq), " (100%)")
ft <- add_footer_row(ft, values = c("Totaal", paste(sum(testframe$freq), " (100%)"), paste(sum(testframe$freq.1), " (100%)")), colwidths = c(1,1,1))#as_paragraph(sum(freq), " (100%)"), as_paragraph(sum(freq.1), " (100%)")))
ft <- fontsize(ft, size = 11, part = "footer")
ft <- align(ft, j = 2:3, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

ft <- autofit(ft)

ft

```