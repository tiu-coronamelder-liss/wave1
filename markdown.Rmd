---
title: "CoronaMelder rapportage"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "11/11/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# For importing SPSS files
library(foreign)

# For filtering
library(dplyr)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]
```

# Resultaten descriptieve statistiek

Even een testje om wat demografische informatie weer te geven, in dit geval leeftijd in categorieën!

```{r demographics, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ages <- table(data$lftdcat)
pl <- barplot(ages, main="Leeftijdscategorieën van respondenten", xaxt="n")
labs <- paste(names(table(data$lftdcat)))
text(cex=0.8, x=pl+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)

```

## Meldingen en reacties op adviezen gegeven in de melding

### Ontvangen meldingen en opvolging adviezen
```{r meldingen, echo=FALSE}
# Om onderstaande tekst wat duidelijker te maken zouden we ook hier variabelen kunnen aanmaken, en alleen die in de tekst terug laten komen, bv.
num_users <- nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))


# NB: hieronder doe ik een ingewikkelde filter over het krijgen van een melding, die is eigenlijk ook te doen met simpelweg notifications_1 == 'Ja', maar ik wilde even complexe filters demonstreren ;)
```

Van de `r nrow(data)` deelnemers, hadden er `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))` de app geïnstalleerd, en `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))` hadden hem nu niet meer geïnstalleerd, maar wel gehad. In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app.

```{r awareness, echo=FALSE}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
aware <- table(data$Awareness)
plotaware <- barplot(aware, main="Bekendheid met CoronaMelder", xaxt="n")
labs <- paste(names(table(data$Awareness)))
text(cex=0.8, x=plotaware+0.25, y=-25, labels=labs, xpd=TRUE, srt=45, pos=2)

# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat, y='n')) + geom_bar(position=position_fill(reverse = TRUE), stat="identity") + guides(fill = guide_legend(reverse = TRUE))

```

``` {r awaresplitssex, echo=FALSE}
ggplot(data=data, aes(x=Awareness, y=Awareness)) + geom_bar(stat="identity") + facet_wrap(~geslacht)
```


# Overige analyses

## Opvolging van advies om je te laten testen

``` {r adherence, echo=FALSE}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# Custom kleurtjes -- we lenen zwart uit 'RdGy' voor "ik ben niet van plan de coronamelder te gebruiken",
# dan van oranje naar groen voor de overige opties (oneens -> eens):
my_palette = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + ggtitle("Als ik wel/geen symptomen heb, zou ik bellen om een coronatest aan te vragen.") + scale_fill_manual(values=my_palette)

```
