---
title: "CoronaMelder rapportage Wave 1 (preliminaire status: resultaten onder voorbehoud)"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "04/12/2020"
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
---
```{r setup, include=FALSE}
# All decimals are commas instead of periods (Dutch formatting style)
# Does not work for tables -- leaving it as period for consistency
#options(OutDec=",")

knitr::opts_chunk$set(echo = TRUE)

rm(list = ls()) #Clear workspace

# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)
library(arsenal)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# For analysis and data preprocessing
library(psy) # psy for the cronbach function
library(reshape2) # For converting from wide to long format (function: melt)
library(rcompanion) # For the posthoc chi square tests

# For aligning ggplots vertically
library(cowplot)

# Other
library(labelled)

##### Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

##### Preprocessing cleaning up variables
### Drop unused levels from some particular factors. The reason to do this is that there are levels in the dataset that were not included in the current sample (for instance participants of child age)
data$lftdcat = droplevels(data$lftdcat)
data$belbezig = droplevels(data$belbezig)

### Combine some variable levels in order to have sufficient counts in cells for demographics
# For demographic variable stedelijkheid. 
data$sted_simplified = data$sted
levels(data$sted_simplified) <- c(levels(data$sted_simplified),"Onbekend") # Add the new level that will contain the merged levels
data$sted_simplified[is.na(data$sted)] <- "Onbekend"
data$sted_simplified = factor(data$sted_simplified)

# For demographic variable oplmet. 
data$oplmet_simplified = data$oplmet
data$oplmet_simplified[data$oplmet == "anders" | data$oplmet == "(Nog) geen onderwijs afgerond" | data$oplmet == "Volgt nog geen onderwijs"] <- "anders"
data$oplmet_simplified = factor(data$oplmet_simplified)

# For demographic variable belbezig. 
data$belbezig_simplified = data$belbezig
levels(data$belbezig_simplified) <- c(levels(data$belbezig_simplified),"Anders") # Add the new level that will contain the merged levels
data$belbezig_simplified[data$belbezig == "Werkt of is meewerkend in gezins- of familiebedrijf" | data$belbezig == "Zoekt voor het eerst werk" | data$belbezig == "Zoekt werk na verlies werkkring" | data$belbezig == "Verricht onbetaald werk met behoud van uitkering" | data$belbezig == "Verricht vrijwilligerswerk" | data$belbezig == "Vrijgesteld van werkzoeken na verlies van werkkring" |data$belbezig == "Doet iets anders"] <- "Anders"
data$belbezig_simplified = factor(data$belbezig_simplified)
#View(data[,c("belbezig","belbezig_simplified")])

# For demographic variable burgstat. Add the people that are "Gescheiden van tafel en bed" to the "Gescheiden categorie"
data$burgstat_simplified = data$burgstat
data$burgstat_simplified[data$burgstat == "Gescheiden van tafel en bed"] <- "Gescheiden"
data$burgstat_simplified = factor(data$burgstat_simplified)

# For demographic variable nettocat. Make category with 3501 euro or higher and unknown ("weet ik niet" en "wil niet zeggen" en NMISS) 
data$nettocat_simplified = data$nettocat
levels(data$nettocat_simplified) <- c(levels(data$nettocat_simplified),"Meer dan EUR 3501", "Onbekend") # Add the new level that will contain the merged levels
data$nettocat_simplified[data$nettocat == "Dat weet ik echt niet" | data$nettocat == "Dat wil ik niet zeggen" | is.na(data$nettocat)] <- "Onbekend"
data$nettocat_simplified[data$nettocat == "EUR 3501 t/m EUR 4000" | data$nettocat == "EUR 4001 t/m EUR 4500" | data$nettocat == "EUR 4501 t/m EUR 5000" | data$nettocat == "EUR 5001 t/m EUR 7500" | data$nettocat == "Meer dan EUR 7500"] <- "Meer dan EUR 3501"
data$nettocat_simplified = factor(data$nettocat_simplified)

### Add labels to variables
attr(data$geslacht,'label')  <- 'Geslacht'
attr(data$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'

##### Set up color palettes for graphs
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]

# Custom coloring:
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])
my_palette5true <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(6,7,8,9)])
my_palette5blue <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "Blues")[c(6,5,4,3)])
my_palette7blue <- brewer.pal(11, "Blues")[c(7,6,5,4,3,2,1)]

##### Creating new variables
## User status. 
# Of interest is the comparison of current users and current non users.  
data$user_status[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt"] <- "Niet gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"

# Add factor
data$user_status <- factor(data$user_status,levels = c("Gebruiker", "Niet gebruiker", "Voormalig gebruiker"))

## User status and intention. 
# Of interest is the comparison of current users and the non users that are neutral when it comes to intention.  
data$user_status_intention[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee oneens'| data$BI1a_UTAUT == 'Oneens'| data$BI1a_UTAUT == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Neutraal')] <- "Nooit gebruikt en neutraal"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee eens'| data$BI1a_UTAUT == 'Mee eens'| data$BI1a_UTAUT == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan"
data$user_status_intention[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"
#View(data[,c("Behavior_UTAUT","BI1a_UTAUT","user_status_intention")])

# Add factor
data$user_status_intention <- factor(data$user_status_intention,levels = c("Gebruiker", "Nooit gebruikt en niet van plan", "Nooit gebruikt en neutraal", "Nooit gebruikt en wel van plan", "Voormalig gebruiker"))

##### Create new datasets
### Create a dataset with only the current users and never users for all analyses in which these groups are compared. 
data_currentvsneveruser = data[ which(data$user_status=='Gebruiker' | data$user_status=='Niet gebruiker'), ]
# Drop unused levels
data_currentvsneveruser$user_status = droplevels(data_currentvsneveruser$user_status)
# Add labels to variables
attr(data_currentvsneveruser$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruser$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruser$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruser$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruser$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruser$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruser$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruser$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data_currentvsneveruser$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'

### Create a dataset with only the curent users and never users that are neutral on intention for all analyses in which these groups are compared. 
data_currentvsneveruserneutral = data[ which(data$user_status_intention=='Gebruiker' | data$user_status_intention=='Nooit gebruikt en neutraal'), ]
# Drop unused levels
data_currentvsneveruserneutral$user_status_intention = droplevels(data_currentvsneveruserneutral$user_status_intention)
# Add labels to variables
attr(data_currentvsneveruserneutral$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruserneutral$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruserneutral$sted,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruserneutral$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruserneutral$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruserneutral$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruserneutral$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruserneutral$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data_currentvsneveruserneutral$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'


## Health literacy
# To enable a median split, labels are first recoded to numbers 
data$HealthLiteracy1n = recode(data$HealthLiteracy1, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)
data$HealthLiteracy2n = recode(data$HealthLiteracy2, 'Helemaal niet'=1, 'Een klein beetje'=2, 'Een beetje'=3, 'Nogal'=4,  'Heel erg'=5)
data$HealthLiteracy3n = recode(data$HealthLiteracy3, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)

# Since items HealtLiteracy1 and 3 are negatively phrased they will be reverse coded such that higher numbers refer to higher health literacy
data$HealthLiteracy1nr = recode(data$HealthLiteracy1n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 
data$HealthLiteracy3nr = recode(data$HealthLiteracy3n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 

# Calculate construct and cronbach alpha (0.58 - poor). The reliability of the scale is low and based on the histogram the distribution is highly skewed; no further analysis of this variable will be done. 
data$HealthLiteracy <- rowMeans(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")], na.rm = TRUE)
cronbach(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")])
#hl_avg <- mean(data$HealthLiteracy)
#hist(data$HealthLiteracy)
# Data splitsen hoge vs. midden. vs lage health literacy
#data$CatHL <- cut(data$HealthLiteracy, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

# Calculate size of user subgroups
# Lookup table for totals of different user groups
usergroup_names = c("users", "nonusers", "nonusers_no_intention", "nonusers_neutral", "nonusers_intention")

usergroup_labels = c("Gebruikers", "Niet gebruikers", "Niet gebruikers - niet van plan om te gaan gebruiken", "Niet gebruikers - neutraal", "Niet gebruikers - wel van plan om te gaan gebruiken")

# Create dataframe for totals of each user group
user_totals <- data.frame(matrix(ncol = length(usergroup_names), nrow = 1))
colnames(user_totals) <- usergroup_names

# Current user
user_totals[1] <- sum(data$user_status == "Gebruiker")

# Non user
user_totals[2] <- sum(data$user_status == "Niet gebruiker")

# Non user -- not planning to use
user_totals[3] <- sum(data$user_status_intention == "Nooit gebruikt en niet van plan")

# Non user -- neutral
user_totals[4] <- sum(data$user_status_intention == "Nooit gebruikt en neutraal")

# Non user -- planning to use
user_totals[5] <- sum(data$user_status_intention == "Nooit gebruikt en wel van plan")

```
\newpage
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
## Methode {.unlisted .unnumbered}
## Resultaten {.unlisted .unnumbered}
## Conclusie {.unlisted .unnumbered}
## Aanbevelingen {.unlisted .unnumbered}
\newpage
# Achtergrond
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.
\newpage  
  
# Methoden  

## Onderzoeksopzet  

In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen zullen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren. Meer specfifiek gaan we in dit longitudinale onderzoek in op de volgende onderzoeksvragen:
  
Onderzoeksvraag 1: Wat is de temporele dynamiek van de adoptie van digitale contracttracering in de Nederlandse bevolking en welke factoren (persoonlijk, sociaal, omgevingsfactoren) hebben hierop betrekking? 
  
Onderzoeksvraag 2: Wat is de temporele dynamiek van de intentie om zich te houden aan de adviezen die worden gecommuniceerd in de digitale contacttracing app CoronaMelder en welke factoren (persoonlijk, sociaal, omgeving, app-gerelateerd) zijn hierop van invloed? 

De huidige rapportage beslaat de data van de eerste meting. De datacollectie (wave 1) van deze rapportage vond plaats tussen 19 oktober en 1 november 2020, 1.5 week na de landelijke lancering op 10 oktober 2020. Vervolgmetingen vinden plaats 1.5 maand na lancering (wave 2: 07-12 t/m 20-12), 3 maanden na lancering (18-01 t/m 31-01) en 5 maanden na lancering (15-03 t/m 29-03). 

De (9 minuten durende) vragenlijst bevat op elk meetmoment de volgende onderwerpen:   
- Gebruiksgedrag van CoronaMelder  
- Technologische factoren die zijn afgeleid van de Unified Theory of Acceptance and Use of Techology (UTAUT): prestatieverwachting, inspanningsverwachting, sociale invloed en gedragsintentie. 
- COVID-19 en CoronaMelder-gerelateerde percepties en overtuigingen  
- Overtuigingen over de voordelen en de persoonlijke/maatschappelijke waarde van de CoronaMelder  
- Misvattingen over Covid-19 en CoronaMelder  
- Persoonlijke, sociale en omgevingsfactoren   
- Preventief gedrag / naleving van adviezen en factoren die zijn afgeleid van het Health Belief Model (HBM): Preventief gedrag (afgelopen week en intentie), waargenomen ernst en vatbaarheid, persoonlijke voordelen en barrières, zelfredzaamheid  

Sommige items zijn aan verandering onderhevig (bijvoorbeeld items over misvattingen over de app of Covid-19 zullen gebaseerd zijn op de meest recente ontwikkelingen en actuele gebeurtenissen in de media). In de bijlage kan de vragenlijst van wave 1 gevonden worden. 

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invullen via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen € 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk standaard bijna een maand duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 1 
Steekproef meting 1: Een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst ‘Health’ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  

Responsoverzicht | 
------------- | -------------
Selectie aantal leden huishouden: | 2.093 (100,0%)  
Nonrespons | 183 (8,7%)  
Respons | 1.910 (91,3%)  
  Compleet | 1.900 (90,8%)  
  Incompleet | 10 (0,5%)  

Datum van dataverzameling: 19 oktober 2020 – 1 november 2020.

In de resultaten sectie worden de uitkomsten getoond van de 1900 respondenten waarbij de data compleet was. Ook word er een overzicht van de karakteristieken van de steekproef getoond. In de bijlage kan een vergelijking van de demografische samenstelling van de steekproef in vergelijking met die van de Nederlandse bevolking (op basis van gegevens van het CBS) gevonden worden. 

\newpage

# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren
Aan dit onderzoek hebben `r nrow(data)` (gemiddelde leeftijd in jaren: `r round(mean(data$leeftijd), digits = 1)`, standaarddeviatie: `r round(sd(data$leeftijd), digits = 1)`, range: `r min(data$leeftijd)`-`r max(data$leeftijd)`); `r round((nrow(filter(data, geslacht == 'Vrouw'))/nrow(data))*100, digits = 2)`% vrouw) respondenten deelgenomen. 

```{r, echo=FALSE, results="asis"} 
tab.noby <- tableby(~ geslacht + lftdcat + sted_simplified + belbezig_simplified + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm + Riskgroup_contact, data=data)
summary(tab.noby)
```

### Gezondheidsmotivatie en risicoperceptie corona besmetting

#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
In de vragenlijst werd gevraagd of de respondenten zelf of mensen in hun directe omgeving besmet zijn (geweest) met het coronavirus. In totaal gaven `r round(nrow(filter(data, CoronaInfectionSelf == 'Ja'))/nrow(data)*100, digits = 1)`% van de respondenten het antwoord *Ja* op de vraag of zij zelf dachten besmet te zijn (geweest) en `r round(nrow(filter(data, CoronaInfectionSelf == 'Nee'))/nrow(data)*100, digits = 1)`% antwoorde hierop *Nee*. Een substantieel percentage (`r round(nrow(filter(data, CoronaInfectionSelf == 'Ik weet het niet'))/nrow(data)*100, digits = 1)`%) gaf aan dit niet te weten.

Ook werd gevraagd of er wel eens een coronatest bij de respondent was afgenomen. Hierop antwoorde `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, een keer'))/nrow(data)*100, digits = 1)`% dat er 1 keer een test was afgenomen en `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, meerdere keren'))/nrow(data)*100, digits = 1)`% dat er al meerdere keren een test was afgenomen. De rest (`r round(nrow(filter(data, CoronaInfectionSelfTest == 'Nee'))/nrow(data)*100, digits = 1)`)% gaf aan dat er nog nooit een test was afgenomen. 

Van de mensen bij wie al minstens een keer een test was afgenomen (`r  nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren')))`), gaf  `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Ja' | CoronaInfectionSelfTest_2 == 'Ja'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% aan dat een van deze testen positief was, `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Nee' | CoronaInfectionSelfTest_2 == 'Nee'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% gaf aan dat de test negatief was en de rest (`r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Weet ik (nog) niet' | CoronaInfectionSelfTest_2 == 'Weet ik (nog) niet'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`%) gaf aan dit (nog) niet te weten. 

In totaal `r round(nrow(filter(data, (CoronaInfectionOther_1 == 'Ja' | CoronaInfectionOther_2 == 'Ja' | CoronaInfectionOther_3 == 'Ja' | CoronaInfectionOther_4 == 'Ja' | CoronaInfectionOther_5 == 'Ja' | CoronaInfectionOther_6 == 'Ja')))/nrow(data)*100, digits = 1)`% gaf aan dat iemand in hun directe omgeving besmet is (geweest)  met het coronavirus.

--> To do: In onderstaande grafiek is te zien welke relatie deze personen tot de respondent hadden (grafiek nog netjes maken) (zie figuur \@ref(fig:coronainfectionother)). 

```{r coronainfectionother, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Relatie geïnfecteerde personen tot de respondent"}
# Create the plot#LUKT NOG NIET
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("CoronaInfectionOther_1", 
                        "CoronaInfectionOther_2", 
                        "CoronaInfectionOther_3", 
                        "CoronaInfectionOther_4",
                        "CoronaInfectionOther_5",
                        "CoronaInfectionOther_6",
                        "CoronaInfectionOther_7",
                        "CoronaInfectionOther_8")
graph_questionlabels = c("Ja, mijn partner", 
                         "Ja, een of meerdere familieleden", 
                         "Ja, een of meerdere vrienden", 
                         "Ja, een of meerdere collega’s/studiegenoten",
                         "Ja, een of meerdere kennissen",
                         "Anders",
                         "Nee, niemand",
                         "Weet ik niet/wil ik niet zeggen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

#### Corona risicoperceptie en ernst
Uit gedragswetenschappelijke literatuur is bekend dat gepercipieerde ernst en vatbaarheid voor een ziekte een rol kan spelen in de acceptatie van gezondheidsadviezen. Ongeveer de helft van de steekproef acht zichzelf vatbaar voor het coronavirus: `r round((nrow(filter(data, (HBM_PSus_self1 == 'Helemaal mee eens'| HBM_PSus_self1 == 'Mee eens'| HBM_PSus_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% gaf aan het eens te zijn met de stelling dat men risico loopt op een besmetting in de komende twee maanden (zie figuur \@ref(fig:riskperception)). Daarnaast was een vergelijkbaar percentage (`r round((nrow(filter(data, (HBM_PSus_other2 == 'Helemaal mee eens'| HBM_PSus_other2 == 'Mee eens'| HBM_PSus_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) het in meer of mindere mate eens met de stelling dat de kans groot is om een ander te besmetten indien men zelf besmet raakt.

De gepercipieerde ernst lag hoger onder de respondenten, met name de ernst van het besmetten van anderen (`r round((nrow(filter(data, (HBM_PSev_other2 == 'Helemaal mee eens'| HBM_PSev_other2 == 'Mee eens'| HBM_PSev_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Daarnaast vindt `r round((nrow(filter(data, (HBM_PSev_self1 == 'Helemaal mee eens'| HBM_PSev_self1 == 'Mee eens'| HBM_PSev_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% het erg om zelf besmet te raken met het coronavirus.

```{r riskperception, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Waargenomen ernst en vatbaarheid - hele populatie", tab.cap="Waargenomen ernst en vatbaarheid - hele populatie"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
baseplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

ggdraw(baseplot)

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Naleven algemene gedragsregels
In kaart is gebracht in hoeverre de respondenten zich in de afgelopen 2 maanden aan een aantal van de algemene gedragsregels hebben gehouden (zie figuur \@ref(fig:behavioradhgenmeasures)). `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd'| Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'))) /nrow(data))*100, digits = 1)`% gaf aan, regelmatig, vaak of altijd handen te wassen. Ongeveer de helft van de respondenten (`r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| Behavior_AdherenceGeneralMeasures_distance == 'Soms'))) /nrow(data))*100, digits = 1)`%) gaf aan nooit, zelden of soms op minder dan 1,5 afstand van mensen buiten het huishouden te zijn geweest. Tot slot gaf `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'))) /nrow(data))*100, digits = 1)`% aan nooit, zelden of soms op een plek te zijn geweest waar anderhalve meter afstand houden eigenlijk niet mogelijk was. 

```{r behavioradhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels", tab.cap="Naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance", 
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces")
graph_questionlabels = c("... hebt u uw handen gewassen?", 
                         "... bent u minder dan op 1,5m afstand geweest van mensen buiten uw huishouden?", 
                         "... bent u op een plek geweest waar het eigenlijk te druk was om 1,5m afstand te houden?"); 
plot_title = "In de afgelopen 2 maanden, hoe vaak..."

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van alle respondenten gaf `r round(nrow(filter(data, Corona_complaints == "Ja"))/nrow(data)*100, digits =1)`% aan klachten te hebben gehad die passen bij het coronavirus in de afgelopen twee maanden. Onderstaande grafiek (figuur \@ref(fig:coronacomplaintsquarantaine)) laat zien in hoeverre deze respondenten in quarantaine bleven: in totaal gaf `r round((nrow(filter(data, Corona_complaints == "Ja" & (Behavior_AdherenceGeneralMeasures_quarantaine == 'Nooit'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Zelden'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Soms'))) /nrow(filter(data, Corona_complaints == "Ja")))*100, digits = 1)`% nooit, zelden of soms naar buiten te zijn geweest met klachten.

```{r coronacomplaintsquarantaine, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels bij klachten"}


# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Bent u, toen u deze klachten had, naar buiten geweest?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Nooit", "Zelden", "Soms", "Regelmatig", "Vaak", "Meestal", "Altijd"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Corona_complaints=='Ja'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = graph_answercategories # For some reason, in this case it does not need to be reverted.
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot naleving algemene gedragsregels
Er is gevraagd naar in welke mate men van plan is om zich de komende twee maanden te houden aan een aantal van de algemene gedragsregels. Het percentage respondenten dat aangeeft de intentie te hebben om zich aan de voorgestelde gedragsregels te houden ligt hoog (handen regelmatig wassen: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; afstand houden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; drukke plekken vermijden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven bij klachten: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Onderstaande figuur geeft de intenties weer (figuur \@ref(fig:intentionadhgenmeasures)).

```{r intentionadhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot naleving algemene gedragsregels", tab.cap="Intentie tot naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance", 
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces", 
                        "Intention_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden", 
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus"); 
plot_title = "Ik ben van plan om de komende 2 maanden..."
# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Algemene opvattingen over het coronavirus

#### Complottheorieën
Om in kaart te brengen in hoeverre complottheorieën een rol spelen is gevraagd of men dacht dat onderstaande stellingen waar of onwaar zijn (zie figuur \@ref(fig:complot)). Van de respondenten beoordeelt `r round((nrow(filter(data, (Beliefs_Conspiracy1 == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% de stelling 'Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt' met misschien waar of zeker waar. Een kleiner percentage beoordeelt de stelling 'De uitbraak van het coronavirus heeft te maken met het 5G netwerk' als misschien waar of zeker waar (`r round((nrow(filter(data, (Beliefs_Conspiracy2 == 'Zeker waar'| Beliefs_Conspiracy2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r complot, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof in complottheorien", tab.cap="Geloof in complottheorien"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

#table(data$Beliefs_Conspiracy1)

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Vertrouwen in aanpak van de overheid
Respondenten zijn verdeeld wat betreft vertrouwen in de overheid met betrekking tot de aanpak van de coronacrisis (zie figuur \@ref(fig:trustgovernment)). Ongeveeer de helft is het eens met de stelling stelling 'Ik heb vertrouwen in de manier waarop de Nederlandse ovreheid probeert het coronavirus onder controle te houden' (`r round((nrow(filter(data, (Beliefs_TrustGovernment == 'Helemaal mee eens'| Beliefs_TrustGovernment == 'Mee eens'| Beliefs_TrustGovernment == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r trustgovernment, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Vertrouwen in de Nederlandse overheid"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")
graph_questionlabels = c("Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

## Bekendheid en gebruik
### Bekendheid met CoronaMelder
In de vragenlijst werd gevraagd hoe bekend men (voor het openen van de vragenlijst) was met de CoronaMelder app. In totaal gaf `r round(((nrow(filter(data, Awareness == 'Heel erg bekend')) + nrow(filter(data, Awareness == 'Bekend')) + nrow(filter(data, Awareness == 'Redelijk bekend'))+ nrow(filter(data, Awareness == 'Een beetje bekend')))/nrow(data)*100), digits = 1)`% aan in meer of mindere mate bekend te zijn met de CoronaMelder (zie figuur \@ref(fig:awareness)). Ruim 1 op de 10 (`r round(nrow(filter(data, Awareness == 'Niet bekend'))/nrow(data)*100, digits = 1)`%) gaf aan niet bekend te zijn met de CoronaMelder.   

--> To do: Verdere uitplitsingen. 

```{r awareness, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Bekendheid met CoronaMelder", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ggplot(data=data, aes(x = Awareness)) + theme_bw() + xlab(paste(names(table(data$Awareness)))) + ylab(" ") + xlab("Hoe bekend bent u met de CoronaMelder?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))
```

```{r awarenesslftd, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per leeftijdscategorie"}
# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per geslacht"}
# Awareness op gender
ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### Gebruik CoronaMelder
Van alle respondenten gaf `r round(nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))/nrow(data)*100, digits = 1)`% aan dat hij/zij de CoronaMelder op dit moment gebruikt en `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))/nrow(data)*100, digits = 1)`% geeft aan de CoronaMelder niet te gebruiken. Slechts `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))/nrow(data)*100, digits = 1)`% gaf aan de CoronaMelder in het verleden gebruikt te hebben maar op dit moment niet meer. 

#### Vergelijking gebruikers en niet gebruikers
##### Demografische gegevens naar gebruikersstatus {#demo_userstatus}
Om inzicht te krijgen in welke factoren (demografisch, persoonlijk, sociaal, omgevingsfactoren) samenhangen met het gebruiken van de CoronaMelder worden respondenten die momenteel de CoronaMelder gebruiken vergeleken met de respondenten die de CoronaMelder nooit hebben gebruikt. 

Om dit te onderzoeken wordt voor elke demografische variabele een chi kwadraat toets uitgevoerd. In het geval dat deze toets aangeeft dat de demografische variabele en de gebruikersstatus afhankelijk zijn - oftewel dat een of meerdere van de subgroepen afwijken van het gemiddelde percentage gebruikers - worden er posthoc paarsgewijze chi kwadraattests met FDR correctie uitgevoerd om te bepalen welke groepen significant van elkaar verschillen in percentage gebruikers. In tabel \ref(demobyuserstatus) kunnen de resultaten gevonden worden. In de appendix kunnen alle paarsgewijze vergelijkingen gevonden worden voor variabelen die samen hingen met de gebruikersstatus. 

Het percentages gebruikers was niet gelijk verdeeld over alle leeftijdscategorieën. Het percentage gebruikers was significant lager bij de 15 - 24 jarigen vergeleken met de 55 - 64 jarigen. 

Nog een demografische variabele die samenhing met gebruik was opleidingsniveau. Bij de hoger opgeleiden (ho en wo) was het percentage gebruikers het hoogst. Bij mensen die aleen basisonderwijs of vmbo hebben gevolgd was dit percentage het laagst. Ook netto maandkomen hing samen met gebruik mensen die maandelijks meer dan 3501 eur netto verdienen gebruiken de CoronaMelder het vaakst terwijl dit percentage bij mensen met een lager inkomen een stuk lager is. 

Ook burgerlijke staat hing samen met gebruik van de CoronaMelder. Zo wordt de CoronMelder minder vaak gebruikt door weduwen en weduwnaars en het vaakst door gehuwden. 


```{r demobyuserstatus, echo=FALSE, results="asis", tab.cap = "Demografische kenmerken naar gebruikersstatus"} 
tab.noby <- tableby(user_status ~ geslacht + lftdcat + sted_simplified + belbezig_simplified  + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm + Riskgroup_contact, cat.stats = "countrowpct", data=data_currentvsneveruser) # cat.stats = "countrowpct") for row percentages in stead of column percentages
summary(tab.noby, pfootnote=TRUE)
```

##### Gezondheidsmotivatie en algemene opvattingen over het coronavirus naar gebruikersstatus

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r perceivedsuscsev, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```
#### Naleving en intentie tot naleving algemene gedragsregels naar gebruikersstatus
Relevant om te weten is of de mensen die de CoronaMelder momenteel gebruiken, mensen zijn die zich in het algemeen al beter aan de gedragsregels houden. 

Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  
```{r chiintentiondistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviordistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_distance == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_distance == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_distance == 'Soms'| data$Behavior_AdherenceGeneralMeasures_distance == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiIntentionadherencequarantaine, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_quarantaine_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf intentie te hebben om in quarantaine te gaan in geval van klachten vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap = "Intentie tot houden aan algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens) per gedragsadvies. Ik ben van plan om de komende 2 maanden ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance",
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces",
                        "Intention_AdherenceGeneralMeasures_quarantaine"
                        )                     
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden",
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r, echo=FALSE, tab.cap = "Zelfgerapporteerde naleving algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage hoogfrequent (vaak, meestal en altijd) per gedragsadvies. In de afgelopen 2 maanden, hoe vaak ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance",
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces"
                        )                     
graph_questionlabels = c("... hebt u uw handen gewassen met water en zeep?", 
                         "... bent u minder dan op 1,5 meter afstand geweest van mensen buiten uw huishouden?",
                         "... bent u op een plek geweest waar het eigenlijk te druk was om de 1,5 meter afstand te houden?"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Vaak", "Meestal", "Altijd")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```



### Intentie tot (blijvend) gebruik CoronaMelder
Er werd gevraagd of de respondenten de intentie hadden om de CoronaMelder de komende twee maanden te (blijven) gebruiken. Van de respondenten die de CoronaMelder app nooit hebben gebruikt, gaf `r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens'| BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan van plan te zijn om de CoronaMelder te gebruiken in de komende twee maanden (zie figuur \@ref(fig:intentiontousenonusers)). Ongeveer een kwart geeft aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1a_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%). Bijna 6 op de 10 respondenten (`r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee oneens'| BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) geeft aan niet van plan te zijn de CoronaMelder te gaan gebruiken.  

```{r intentiontousenonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1a_UTAUT", 
                        "BI2a_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder in de komende 2 maanden zal gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van de respondenten die de CoronaMelder op dit moment al gebruiken, gaf een overgrote meerderheid (`r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) aan van plan te zijn de CoronaMelder te blijven gebruiken in de komende 2 maanden (zie figuur \@ref(fig:intentiontousecurrentusers)). Een kleine hoeveelheid respondenten gaf aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) Slechts `r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% gaf aan niet van plan te zijn de CoronaMelder te blijven gebruiken. 

```{r intentiontousecurrentusers, eval=FALSE, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1b_UTAUT", 
                        "BI2b_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te blijven gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder de komende 2 maanden zal blijven gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r IntentieHL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
#df_PSev %>% filter(!is.na(Value))

data_nona1a <- data[!is.na(data$BI1a_UTAUT),]
data_nona1b <- data[!is.na(data$BI1b_UTAUT),]

#ggplot(data=data_nona1a, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
#ggplot(data=data_nona1b, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

rm(data_nona1a)
rm(data_nona1b)
```

## Verklarende variabelen voor adoptie
### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
In kaart is gebracht in welke mate men denkt dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. In totaal gaf `r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan het eens te zijn met de stelling dat men door het gebruiken van de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. Daarnaast gaf `r round((nrow(filter(data, (PE2_UTAUT == 'Helemaal mee eens'| PE2_UTAUT == 'Mee eens'| PE2_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt en geeft `r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verwachte effeciviteit CoronaMelder", tab.cap="Verwachte effeciviteit CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er is ook gevraagd hoeveel procent van de Nederlandse bevolking volgens de respondent de CoronaMelder app zou moeten gebruiken om de verspreiding van het coronavirus tegen te gaan. De meeste respondenten (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%'))/nrow(data)*100, digits = 1)`%) dachten dat 76-90% van de Nederlandse bevolking de CoronaMelder moet gebruiken om de verspreiding van het coronavirus tegen te gaan. In totaal dacht `r round(((nrow(filter(data, Beliefs_ResponseefficasyOther == '51-75%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '91-100%')))/nrow(data)*100), digits = 1)`% van de respondenten dat meer dan 50% van de Nederlandse bevolking de CoronaMelder app moet gebruiken om effectief te zijn. Het aandeel respondenten dat aan gaf niet te weten hoeveel mensen de CoronaMelder app zouden moeten gebruiken is `r round(nrow(filter(data, Beliefs_ResponseefficasyOther == 'Weet ik niet'))/nrow(data)*100, digits = 1)`%. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan"}
# Beliefs_ResponseefficasyOther
ggplot(data=data, aes(x = Beliefs_ResponseefficasyOther)) + theme_bw() + xlab(paste(names(table(data$Beliefs_ResponseefficasyOther)))) + ylab(" ") + xlab("Hoeveel procent van de Nederlandse bevolking zou volgens u de CoronaMelder moeten gebruiken om de verspreiding van het coronavirus tegen te gaan?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))

```

#### Verwachte effectiviteit CoronaMelder naar gebruikersstatus
```{r chiPE1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiPE2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiBeliefsprotectriskgroupsusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).
```{r chiBeliefsprotectriskgroupsusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap = "Verwachte effectiviteit CoronaMelder naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```





### Vertrouwen in adequaatheid techniek
In de vragenlijst werd gepeild in welke mate men vertrouwen heeft in de adequaatheid van de techniek. Het overgrote deel van de respondenten antwoordde 'zeker waar' of 'misschien waar' op de stelling 'De techniek (Bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is' (`r round((nrow(filter(data, (Beliefs_technologyperformance == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 


```{r technology, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Vertrouwen in techniek", tab.cap="Vertrouwen in techniek"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
                        
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Maatschappelijke gevolgen gebruik CoronaMelder
Aan de respondenten werd gevraagd in hoeverre zij dachten dat gebruik van de CoronaMelder de Nederlandse economie helpt. Ongeveer één op de drie respondenten heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen (`r round((nrow(filter(data, (Beliefs_benefiteconomic == 'Helemaal mee eens'| Beliefs_benefiteconomic == 'Mee eens'| Beliefs_benefiteconomic == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r beneficteconomic, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Overtuiging dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Maatschappelijke gevolgen gebruik CoronaMelder naar gebruikersstatus
```{r chiBeliefsbenefiteconomicusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Helemaal mee eens'| data$Beliefs_benefiteconomic == 'Mee eens'| data$Beliefs_benefiteconomic == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Neutraal'| data$Beliefs_benefiteconomic == 'Een beetje oneens'| data$Beliefs_benefiteconomic == 'Oneens'| data$Beliefs_benefiteconomic == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_benefiteconomic_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat gebruik van de CoronaMelder de Nederlandse economie helpt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiBeliefsbenefiteconomicusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Helemaal mee eens'| data$Beliefs_benefiteconomic == 'Mee eens'| data$Beliefs_benefiteconomic == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Neutraal'| data$Beliefs_benefiteconomic == 'Een beetje oneens'| data$Beliefs_benefiteconomic == 'Oneens'| data$Beliefs_benefiteconomic == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_benefiteconomic_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat gebruik van de CoronaMelder de Nederlandse economie helpt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

### Verwachte gebruiksvriendelijkheid en zelfeffectiviteit

```{r effortexpectancynonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1b_UTAUT", 
                        "EE2b_UTAUT")
graph_questionlabels = c("Ik denk dat het mij veel tijd en energie kost om de CoronaMelder te gebruiken", 
                         "Ik denk dat de CoronaMelder makkelijk te gebruiken is"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r effortexpectancyusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment gebruiken", tab.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1a_UTAUT", 
                        "EE2a_UTAUT")
graph_questionlabels = c("Het kost(te) mij veel tijd en energie om de CoronaMelder te gebruiken", 
                         "De CoronaMelder is makkelijk te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```

```{r selfefficacyCM, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Zelfeffectiviteit om CoronaMelder te installeren"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_CoronaMelder")
graph_questionlabels = c("Ik ben in staat om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



### Technologie gerelateerde belemmeringen
Vanuit het UTAUT is bekend dat technologie gerelateerde belemmeringen een rol kunnen spelen in de adoptie van nieuwe technologie. 

```{r , echo=FALSE, fig.width=7, fig.height=2, fig.cap="Technologie gerelateerde belemmeringen", tab.cap="Technologie gerelateerde belemmeringen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Technologie gerelateerde belemmeringen naar gebruikersstatus
```{r chiFC1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Helemaal mee eens'| data$FC1_UTAUT == 'Mee eens'| data$FC1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Neutraal'| data$FC1_UTAUT == 'Een beetje oneens'| data$FC1_UTAUT == 'Oneens'| data$FC1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn beschikking te hebben over een smartphone met internet, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).

```{r chiFC1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Helemaal mee eens'| data$FC1_UTAUT == 'Mee eens'| data$FC1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Neutraal'| data$FC1_UTAUT == 'Een beetje oneens'| data$FC1_UTAUT == 'Oneens'| data$FC1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn beschikking te hebben over een smartphone met internet, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiFC2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Helemaal mee eens'| data$FC2_UTAUT == 'Mee eens'| data$FC2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Neutraal'| data$FC2_UTAUT == 'Een beetje oneens'| data$FC2_UTAUT == 'Oneens'| data$FC2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te installeren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiFC2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Helemaal mee eens'| data$FC2_UTAUT == 'Mee eens'| data$FC2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Neutraal'| data$FC2_UTAUT == 'Een beetje oneens'| data$FC2_UTAUT == 'Oneens'| data$FC2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(round(chisqtest$p.value, digits = 2) < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 2)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te installeren, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
 
```{r, echo=FALSE, tab.cap = "Technologie gerelateerde belemmeringen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT") 
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt")

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```







### Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik
Belangrijke variabelen uit het UTAUT en het HBM zijn de verwachte voor- en nadelen van het gebruik en de mate waarin iemand een verplichting voelt om de techniek te gebruiken. Het percentage van de respondenten dat voordelen ziet van het gebruik ligt vrij laag (`r round((nrow(filter(data, (HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), evenals het percentage dat nadelen ziet van het gebruik (`r round((nrow(filter(data, (HBM_barriers_CoronaMelder == 'Helemaal mee eens'| HBM_barriers_CoronaMelder == 'Mee eens'| HBM_barriers_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Slechts `r round((nrow(filter(data, (Beliefs_voluntariness == 'Helemaal mee eens'| Beliefs_voluntariness == 'Mee eens'| Beliefs_voluntariness == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% voelt zicht verplicht tot het gebruik.

```{r Motivationsbarriersvoluntariness, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik", tab.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder", 
                        "Beliefs_voluntariness")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken", 
                         "Ik voel me verplicht om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Affectieve reacties
In kaart is gebracht in welke mate de CoronaMelder in het algemeen en meer specifiek het ontvangen van een melding een emotionele reaktie opwekt. Bijna een kwart geeft aan de CoronaMelder eng te vinden (`r round((nrow(filter(data, (Beliefs_fear == 'Helemaal mee eens'| Beliefs_fear == 'Mee eens'| Beliefs_fear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), en 
`r round((nrow(filter(data, (Beliefs_fear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% staat hier neutraal tegenover. Een iets groter aandeel zou angstig worden bij het ontvangen van een melding (`r round((nrow(filter(data, (Beliefs_notificationfear == 'Helemaal mee eens'| Beliefs_notificationfear == 'Mee eens'| Beliefs_notificationfear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), hier staat `r round((nrow(filter(data, (Beliefs_notificationfear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% neutraal in.

```{r Affective, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Affectieve reacties", tab.cap="Affectieve reacties"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")
graph_questionlabels = c("Ik vind de CoronaMelder eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



### Sociale invloeden
Om de sociale invloeden in kaart te brengen is gevraagd naar descriptieve en injunctieve normen en is gevraagd om een indicatie te geven van welk percentage van de Nederlandse bevolking de CoronaMelder gebruikt. Opvallend is dat een relatief laag percentage mensen het eens is met de stelling dat veel mensen in hun omgeving de CoronaMelder gebruiken (`r round((nrow(filter(data, (SI1_UTAUT == 'Helemaal mee eens'| SI1_UTAUT == 'Mee eens'| SI1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Dit kan liggen aan het feit dat gebruik van de CoronaMelder redelijk onzichtbaar is (in tegenstelling tot het gebruik van bijvoorbeeld een mondkapje). Daarnaast staat een groot percentage neutraal tegenover deze stelling (`r round((nrow(filter(data, (SI1_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%), wat zou kunnen betekenen dat men hier niet van op de hoogte is.

Ook de injunctieve norm is nauwelijks aanwezig, bijna de helft is het oneeens met de stelling 'Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken' (`r round((nrow(filter(data, (SI2_UTAUT == 'Helemaal mee oneens'| SI2_UTAUT == 'Oneens'| SI2_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`%), en ook een aanzienlijk percentage staat hier neutraal in (`r round((nrow(filter(data, (SI2_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Van de respondenten is `r round((nrow(filter(data, (Beliefs_civicduty == 'Helemaal mee eens'| Beliefs_civicduty == 'Mee eens'| Beliefs_civicduty == 'Een beetje mee eens')))))`% het eens met de stelling dat de CoronaMelder je een goede burger maakt.


```{r Beliefsappadoption, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage bevolking dat volgens de respondent de CoronaMelder gebruikt"}
ggplot(data=data, aes(x = Beliefs_AppAdoption)) + theme_bw() + xlab(paste(names(table(data$Beliefs_AppAdoption)))) + ylab(" ") + xlab("Hoeveel procent van de Nederlandse bevolking denkt u dat de CoronaMelder gebruikt?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))

```


```{r Socialnormscivicduty, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Sociale normen", tab.cap="Sociale normen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Sociale invloeden naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben. Daarnaast is gekeken of de subgroep die de CoronaMelder nooit gebruikt heeft en aangaf neutraal te zijn met betrekking tot toekomstig gebruik verschilt van de huidig gebruikers. 
```{r chiSI1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiSI1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiSI2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Helemaal mee eens'| data$SI2_UTAUT == 'Mee eens'| data$SI2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Neutraal'| data$SI2_UTAUT == 'Een beetje oneens'| data$SI2_UTAUT == 'Oneens'| data$SI2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving vinden dat hij/zij de CoronaMelder moet gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiSI2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Helemaal mee eens'| data$SI2_UTAUT == 'Mee eens'| data$SI2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Neutraal'| data$SI2_UTAUT == 'Een beetje oneens'| data$SI2_UTAUT == 'Oneens'| data$SI2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving vinden dat hij/zij de CoronaMelder moet gebruiken vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap ="Sociale normen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT")                     
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder app", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder app moet gebruiken") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r echo=FALSE, results="asis"}
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger")
# For each of these variables we would like to test if the current users and non users differ in the proportion that agrees with the statement. 
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
#View(data[,c("SI1_UTAUT","SI1_UTAUT_agree")])
testtable = table(data$SI1_UTAUT_agree, data$user_status)
#chisq.test(testtable) 

#tab1 <- tableby(SI1_UTAUT_agree ~ user_status + geslacht + lftdcat + sted + belbezig, data=data_selected)
#summary(tab1)
```

### Privacy en dataveiligheid 
Nog een factor die een rol kan spelen in de adoptie is de verwachting met betrekking tot de privacy en dataveiligheid. Een opvallend groot aandeel beoordeelt de foutieve stellingen dat de CoronaMelder de locatie bijhoudt (`r round((nrow(filter(data, (Beliefs_locationmonitoring == 'Zeker waar'| Beliefs_locationmonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) en dat de CoronaMelder persoonsgegevens opslaat (`r round((nrow(filter(data, (Beliefs_identitymonitoring == 'Zeker waar'| Beliefs_identitymonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) als waar. Daartegenover staat wel dat men het idee heeft dat er vertrouwelijk wordt omgegaan met de informatie (`r round((nrow(filter(data, (Beliefs_datasafety == 'Zeker waar'| Beliefs_datasafety == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 


```{r privacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Privacy overtuigingen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld",
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


## Effecten
### Meldingen en reacties op adviezen gegeven in de melding

```{r adherenceappnotification, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Thuisblijven na melding"}

#KLOPT NOG NIET!!! NAs staan er nog in
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Notification_behavior_quarantaine")
graph_questionlabels = c("Bent u nadat u deze melding(en) kreeg zo lang thuisgebleven als de melding adviseert?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


#### Ontvangen meldingen en opvolging van de adviezen
In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app; dat is `r round(nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))/nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer')))*100, digits = 1)`%.Vanwege dit lage aantal zijn de vervolgvragen voor deelnemers die een melding hebben ontvangen (opvolging van de adviezen, etc.) niet verder bekeken. 

#### Intentie tot opvolgen adviezen gegeven in de melding
Aan de respondenten is gevraagd in hoeverre zij de intentie hebben om, na ontvangen van een melding, zich te houden aan de adviezen die in een melding van de CoronaMelder worden gegeven. Om dit te onderzoeken werd proefpersonen twee sitaties voorgelegd (situatie waarin men wel of geen symptomen had) en een screenshot van de melding getoond. Een belangrijke noot bij deze resultaten is dat ten tijde van deze enquete het testbeleid zo was dat men na het ontvangen van een melding alleen kon laten testen indien symptomen aawezig waren (in de appendix kan de vragenlijst inclusief screenshot van melding gevonden worden). 

In figuur \@ref(fig:adherencenotificationsnosymp) is te zien dat respondenten over het algemeen de juiste intenties hebben wat betreft het opvolgen van geadviseerd gedrag wanneer men geen symptomen heeft. Zo zou ruim twee derde thuisblijven zolang geadviseerd (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), en geen bezoek ontvangen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Iets meer dan één vierde geeft aan een coronatest aan te zullen vragen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts te bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

``` {r adherencenotificationsnosymp, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen", tab.cap="Intentie tot opvolgen adviezen zonder symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 


# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Figuur \@ref(fig:adherencenotificationssympt) laat zien dat respondenten over het algemeen ook de juiste intenties hebben wanneer men wel symptomen heeft. Van de respondenten geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan te bellen voor een coronatest, `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan thuis te blijven zolang geadviseerd, en `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%. Toch geeft ook nog bijna de helft aan de huisarts te zullen bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r adherencenotificationssympt, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen met symptomen", tab.cap="Intentie tot opvolgen adviezen met symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidig gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. 

``` {r adherencenotificationsnosympcurrentusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r adherencenotificationssymptcurrentusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Verklarende factoren opvolging adviezen gegeven in melding
##### Eigen effectiviteit opvolging adviezen
Om de eigen effectiviteit in kaart te brengen werd gevraagd in welke mate men dacht in staat te zijn om de adviezen uit de melding op te volgen. Men acht zichzelf goed in staat om te bellen voor een test (`r round((nrow(filter(data, (HBM_selfefficacy_Test == 'Helemaal mee eens'| HBM_selfefficacy_Test == 'Mee eens'| HBM_selfefficacy_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zo lang thuis te blijven als wordt geadviseerd (`r round((nrow(filter(data, (HBM_selfefficacy_Quarantaine == 'Helemaal mee eens'| HBM_selfefficacy_Quarantaine == 'Mee eens'| HBM_selfefficacy_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), geen bezoek te ontvangen (`r round((nrow(filter(data, (HBM_selfefficacy_Visits == 'Helemaal mee eens'| HBM_selfefficacy_Visits == 'Mee eens'| HBM_selfefficacy_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en de huisarts te bellen (`r round((nrow(filter(data, (HBM_selfefficacy_GP == 'Helemaal mee eens'| HBM_selfefficacy_GP == 'Mee eens'| HBM_selfefficacy_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).


```{r adherencenotificationsselfefficacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit om adviezen op te volgen", tab.cap="Eigen effectiviteit om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_Test", 
                        "HBM_selfefficacy_Quarantaine", 
                        "HBM_selfefficacy_Visits",
                        "HBM_selfefficacy_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Ik ben in staat om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen
Uit het Health Belief Model is bekend dat de mate waarin men verwacht dat een gedrag persoonlijke voor- of nadelen heeft een rol kan spelen in de adoptie van het gedrag. Voor een aantal gedragingen omtrent de opvolging van adviezen zijn deze voor- en nadelen uitgevraagd. Het blijkt dat ongeveer de helft van de respondenten deze persoonlijke voordelen inziet (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Helemaal mee eens'| HBM_perceivedbenefits_Test == 'Mee eens'| HBM_perceivedbenefits_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Helemaal mee eens'| HBM_perceivedbenefits_Quarantaine == 'Mee eens'| HBM_perceivedbenefits_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Helemaal mee eens'| HBM_perceivedbenefits_Visits == 'Mee eens'| HBM_perceivedbenefits_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Helemaal mee eens'| HBM_perceivedbenefits_GP == 'Mee eens'| HBM_perceivedbenefits_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zie figuur \@ref(fig:HBMbenefits). Een aanzienlijke groep staat neutraal tegenover de voordelen om adviezen op te volgen ((bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%.

```{r HBMbenefits, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voordelen om adviezen op te volgen", tab.cap="Persoonlijke voordelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_Test", 
                        "HBM_perceivedbenefits_Quarantaine", 
                        "HBM_perceivedbenefits_Visits",
                        "HBM_perceivedbenefits_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke voordelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Ook met betrekking tot persoonlijke nadelen van het opvolgen van de adviezen blijkt een groot aandeel neutraal te zijn (bellen voor een test: `r round((nrow(filter(data, (HBM_barriers_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_barriers_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_barriers_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Er zit variatie in de mate waarin men het eens is met de stellingen of bepaalde acties persoonlijke nadelen hebben. Het percentage mensen dat het eens is met nadelige gevolgen is het grootst voor thuisblijven (`r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Helemaal mee eens'| HBM_barriers_Quarantaine == 'Mee eens'| HBM_barriers_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en het niet kunnen ontvangen van bezoek (`r round((nrow(filter(data, (HBM_barriers_Visits == 'Helemaal mee eens'| HBM_barriers_Visits == 'Mee eens'| HBM_barriers_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Het bellen voor een test (`r round((nrow(filter(data, (HBM_barriers_Test == 'Helemaal mee eens'| HBM_barriers_Test == 'Mee eens'| HBM_barriers_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts bellen (`r round((nrow(filter(data, (HBM_barriers_GP == 'Helemaal mee eens'| HBM_barriers_GP == 'Mee eens'| HBM_barriers_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) wordt als minder nadelig gezien (zie figuur \@ref(fig:HBMbarriers)).


```{r HBMbarriers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke nadelen om adviezen op te volgen", tab.cap="Persoonlijke nadelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_barriers_Test", 
                        "HBM_barriers_Quarantaine", 
                        "HBM_barriers_Visits",
                        "HBM_barriers_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke nadelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Intentie tot doorgeven GGD-sleutel na positieve test
Als iemand positief is getest op het coronavirus kan men dit daarna via de app laten weten door de GGD-sleutel door te geven aan de GGD medewerker. Dan waarschuwt de app weer mensen bij wie de positief gesteste persoon in de buurt is geweest. Van de respondenten heeft `r round((nrow(filter(data, (Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%  de intentie om de GGD-sleutel door te geven. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot doorgeven GGD-sleutel", tab.cap="Intentie tot doorgeven GGD-sleutel"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Onbeoogde effecten: schijnveiligheid
Een gevoel van schijnveiligheid zou kunnen optreden bij de adoptie van de CoronaMelder, wat ervoor zou kunnen zorgen dat andere maatregelen minder nodig worden geacht. Uit de antwoorden op de stelling of men zich minder aan andere maatregelen kan houden bij het gebruik van de CoronaMelder, blijkt dat slechts een klein aandeel denkt dat dit het geval is. Het aandeel dat op deze vraag 'zeker waar' of 'misschien waar' antwoordt, is `r round((nrow(filter(data, (Beliefs_falsesecurity1 == 'Zeker waar'| Beliefs_falsesecurity1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%. Een iets groter percentage denkt dat de CoronaMelder ervoor zorgt dat je niet besmet kunt raken (`r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Zeker waar'| Beliefs_falsesecurity2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r falsesecurity, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Schijnveiligheid", tab.cap="Schijnveiligheid"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_falsesecurity1",
                        "Beliefs_falsesecurity2")
graph_questionlabels = c("Als ik de CoronaMelder gebruik, hoef ik me minder aan de andere maatregelen te houden",
                         "De CoronaMelder zorgt ervoor dat ik niet besmet raak met het coronavirus"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```







\newpage
# Conclusie en aanbevelingen
## Verwachte effectiviteit  
Verwachting effectiviteit goed. Wel wordt verwacht dat het pas effectief is als een zeer hoog percentage van de populatie de CoronaMelder gebruikt.   

## Sociale invloeden
Zeer lage descriptieve en injunctieve normen mbt. mensen in hun directe omgeving. Redelijk goede inschatting van adoptie in de hele populatie.   

## Schijnveiligheid  

Lijkt niet waarschijnlijk.   

## Zijn gebruikers in het algemeen meer adherent aan de corona gedragsregels?  

Qua intentie wel, qua gedrag niet.   

\newpage
# Referenties
\newpage
# Appendix
## Additionele resulaten: Demografie naar gebruikersstatus - Paarsgewijze vergelijkingen
Vergelijking subgroepen met ruwe p-waarden en FDR-gecorrigeerde p-waarden. 
```{r , echo=FALSE}
### Determine all pairwise comparisons for the demgraphic variables the chi square indicated that the variable was not indepnedent from use status. 
# Age category (lftdcat)
data_selected = data_currentvsneveruser
data_selected$lftdcat = droplevels(data_selected$lftdcat)
chisq.table = table(data_selected$lftdcat, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Educational level (oplmet_simplified)
data_selected = data_currentvsneveruser
data_selected$oplmet_simplified = droplevels(data_selected$oplmet_simplified)
chisq.table = table(data_selected$oplmet_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Marital status (burgstat_simplified)
data_selected = data_currentvsneveruser
data_selected$burgstat_simplified = droplevels(data_selected$burgstat_simplified)
chisq.table = table(data_selected$burgstat_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Net income (nettocat_simplified)
data_selected = data_currentvsneveruser
data_selected$nettocat_simplified = droplevels(data_selected$nettocat_simplified)
chisq.table = table(data_selected$nettocat_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
```
# Bijlagen
Als bijlage kunt u bij dit rapport vinden:
- Vragenlijst wave 1
- Vergelijking demografie sample huidig onderzoek, LISS core panel en CBS













``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
#ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

