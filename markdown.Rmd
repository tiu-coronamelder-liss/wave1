---
title: "CoronaMelder rapportage Wave 1 (preliminaire status: resultaten onder voorbehoud)"
author: "Nynke van der Laan, Nadine van der Waal, Jan de Wit"
date: "01/12/2020"
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
---
```{r setup, include=FALSE}
# All decimals are commas instead of periods (Dutch formatting style)
# Does not work for tables -- leaving it as period for consistency
#options(OutDec=",")

knitr::opts_chunk$set(echo = TRUE)

rm(list = ls()) #Clear workspace

# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)

# Various plotting stuff
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)

# For analysis and data preprocessing
library(psy) # psy for the cronbach function
library(reshape2) # For converting from wide to long format (function: melt)

##### Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the ones that didn't complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

##### Set up color palettes for graphs
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]

# Custom coloring:
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])
my_palette5true <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(6,7,8,9)])
my_palette5blue <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "Blues")[c(6,5,4,3)])

##### Creating new variables
## User status. 
# Of interest is the comparison of current users and current non users.  
data$user_status[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt"] <- "Niet gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"

## User status and intention. 
# Of interest is the comparison of current users and the non users that are neutral when it comes to intention.  
data$user_status_intention[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee oneens'| data$BI1a_UTAUT == 'Oneens'| data$BI1a_UTAUT == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Neutraal')] <- "Nooit gebruikt en neutraal"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee eens'| data$BI1a_UTAUT == 'Mee eens'| data$BI1a_UTAUT == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan"
data$user_status_intention[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"
View(data[,c("Behavior_UTAUT","BI1a_UTAUT","user_status_intention")])

## Health literacy
# To enable a median split, labels are first recoded to numbers 
data$HealthLiteracy1n = recode(data$HealthLiteracy1, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)
data$HealthLiteracy2n = recode(data$HealthLiteracy2, 'Helemaal niet'=1, 'Een klein beetje'=2, 'Een beetje'=3, 'Nogal'=4,  'Heel erg'=5)
data$HealthLiteracy3n = recode(data$HealthLiteracy3, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)

# Since items HealtLiteracy1 and 3 are negatively phrased they will be reverse coded such that higher numbers refer to higher health literacy
data$HealthLiteracy1nr = recode(data$HealthLiteracy1n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 
data$HealthLiteracy3nr = recode(data$HealthLiteracy3n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 

# Calculate construct and cronbach alpha (0.58 - poor). The reliability of the scale is low and based on the histogram the distribution is highly skewed; no further analysis of this variable will be done. 
data$HealthLiteracy <- rowMeans(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")], na.rm = TRUE)
cronbach(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")])
#hl_avg <- mean(data$HealthLiteracy)
#hist(data$HealthLiteracy)
# Data splitsen hoge vs. midden. vs lage health literacy
#data$CatHL <- cut(data$HealthLiteracy, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

# Calculate size of 6 user subgroups
# Lookup table for totals of different user groups
usergroup_variablenames = c("user_woulduse",
                            "user_neutral",
                            "user_wouldnotuse",
                            "nonuser_woulduse",
                            "nonuser_neutral",
                            "nonuser_wouldnotuse")

usergroup_variablelabels = c("Blijvend",
                             "Neutraal",
                             "Stoppend",
                             "Met intentie",
                             "Neutraal",
                             "Geen intentie")

# Create dataframe
user_totals <- data.frame(matrix(ncol = length(usergroup_variablenames), nrow = 1))
colnames(user_totals) <- usergroup_variablenames

# 1. Current user of app, would keep using
user_totals[1] <- nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# 2. Current user of app, neutral about continuing use
user_totals[2] <- nrow(filter(data, BI1b_UTAUT == 'Neutraal' & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# 3. Current user of app, intends to stop using
user_totals[3] <- nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))

# 4. Current non-user, intends to start using
user_totals[4] <- nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens' | BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))

# 5. Current non-user, neutral about starting use -- interesting target for promotion
user_totals[5] <- nrow(filter(data, BI1a_UTAUT == 'Neutraal' & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))

# 6. Current non-user, does not intend to start using
user_totals[6] <- nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee oneens' | BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))
```
\newpage
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
## Methode {.unlisted .unnumbered}
## Resultaten {.unlisted .unnumbered}
## Conclusie {.unlisted .unnumbered}
## Aanbevelingen {.unlisted .unnumbered}
\newpage
# Achtergrond
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.
\newpage  
  
# Methoden  

## Onderzoeksopzet  

In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen zullen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren. Meer specfifiek gaan we in dit longitudinale onderzoek in op de volgende onderzoeksvragen:
  
Onderzoeksvraag 1: Wat is de temporele dynamiek van de adoptie van digitale contracttracering in de Nederlandse bevolking en welke factoren (persoonlijk, sociaal, omgevingsfactoren) hebben hierop betrekking? 
  
Onderzoeksvraag 2: Wat is de temporele dynamiek van de intentie om zich te houden aan de adviezen die worden gecommuniceerd in de digitale contacttracing app CoronaMelder en welke factoren (persoonlijk, sociaal, omgeving, app-gerelateerd) zijn hierop van invloed? 

De huidige rapportage beslaat de data van de eerste meting. De datacollectie (wave 1) van deze rapportage vond plaats tussen 19 oktober en 1 november 2020, 1.5 week na de landelijke lancering op 10 oktober 2020. Vervolgmetingen vinden plaats 1.5 maand na lancering (wave 2: 07-12 t/m 20-12), 3 maanden na lancering (18-01 t/m 31-01) en 5 maanden na lancering (15-03 t/m 29-03). 

De (9 minuten durende) vragenlijst bevat op elk meetmoment de volgende onderwerpen:   
- Gebruiksgedrag van CoronaMelder  
- Technologische factoren die zijn afgeleid van de Unified Theory of Acceptance and Use of Techology (UTAUT): prestatieverwachting, inspanningsverwachting, sociale invloed en gedragsintentie. 
- COVID-19 en CoronaMelder-gerelateerde percepties en overtuigingen  
- Overtuigingen over de voordelen en de persoonlijke/maatschappelijke waarde van de CoronaMelder  
- Misvattingen over Covid-19 en CoronaMelder  
- Persoonlijke, sociale en omgevingsfactoren   
- Preventief gedrag / naleving van adviezen en factoren die zijn afgeleid van het Health Belief Model (HBM): Preventief gedrag (afgelopen week en intentie), waargenomen ernst en vatbaarheid, persoonlijke voordelen en barriÃ¨res, zelfredzaamheid  

Sommige items zijn aan verandering onderhevig (bijvoorbeeld items over misvattingen over de app of Covid-19 zullen gebaseerd zijn op de meest recente ontwikkelingen en actuele gebeurtenissen in de media). In de bijlage kan de vragenlijst van wave 1 gevonden worden. 

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invullen via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen â¬ 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk standaard bijna een maand duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 1 
Steekproef meting 1: Een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst âHealthâ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  

Responsoverzicht | 
------------- | -------------
Selectie aantal leden huishouden: | 2.093 (100,0%)  
Nonrespons | 183 (8,7%)  
Respons | 1.910 (91,3%)  
  Compleet | 1.900 (90,8%)  
  Incompleet | 10 (0,5%)  

Datum van dataverzameling: 19 oktober 2020 â 1 november 2020.

In de resultaten sectie worden de uitkomsten getoond van de 1900 respondenten waarbij de data compleet was. Ook word er een overzicht van de karakteristieken van de steekproef getoond. In de bijlage kan een vergelijking van de demografische samenstelling van de steekproef in vergelijking met die van de Nederlandse bevolking (op basis van gegevens van het CBS) gevonden worden. 

\newpage

# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren
Aan dit onderzoek hebben 1900 (gemiddelde leeftijd in jaren: 51.8, standaarddeviatie 18.3, range: 17-96); 55.1% vrouw) respondenten deelgenomen. 

--> To do: nog uitwerken in tabellen:  
Geslacht
Lftdcat
sted
belbezig
oplmet
DS_mobile
HealthLiteracy
Riskgroup_contact


### Gezondheidsmotivatie en risicoperceptie corona besmetting

#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
In de vragenlijst werd gevraagd of de respondenten zelf of mensen in hun directe omgeving besmet zijn (geweest) met het coronavirus. In totaal gaven `r round(nrow(filter(data, CoronaInfectionSelf == 'Ja'))/nrow(data)*100, digits = 1)`% van de respondenten het antwoord *Ja* op de vraag of zij zelf dachten besmet te zijn (geweest) en `r round(nrow(filter(data, CoronaInfectionSelf == 'Nee'))/nrow(data)*100, digits = 1)`% antwoorde hierop *Nee*. Een substantieel percentage (`r round(nrow(filter(data, CoronaInfectionSelf == 'Ik weet het niet'))/nrow(data)*100, digits = 1)`%) gaf aan dit niet te weten.

Ook werd gevraagd of er wel eens een coronatest bij de respondent was afgenomen. Hierop antwoorde `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, een keer'))/nrow(data)*100, digits = 1)`% dat er 1 keer een test was afgenomen en `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, meerdere keren'))/nrow(data)*100, digits = 1)`% dat er al meerdere keren een test was afgenomen. De rest (`r round(nrow(filter(data, CoronaInfectionSelfTest == 'Nee'))/nrow(data)*100, digits = 1)`)% gaf aan dat er nog nooit een test was afgenomen. 

Van de mensen bij wie al minstens een keer een test was afgenomen (`r  nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren')))`), gaf  `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Ja' | CoronaInfectionSelfTest_2 == 'Ja'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% aan dat een van deze testen positief was, `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Nee' | CoronaInfectionSelfTest_2 == 'Nee'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% gaf aan dat de test negatief was en de rest (`r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Weet ik (nog) niet' | CoronaInfectionSelfTest_2 == 'Weet ik (nog) niet'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`%) gaf aan dit (nog) niet te weten. 

In totaal `r round(nrow(filter(data, (CoronaInfectionOther_1 == 'Ja' | CoronaInfectionOther_2 == 'Ja' | CoronaInfectionOther_3 == 'Ja' | CoronaInfectionOther_4 == 'Ja' | CoronaInfectionOther_5 == 'Ja' | CoronaInfectionOther_6 == 'Ja')))/nrow(data)*100, digits = 1)`% gaf aan dat iemand in hun directe omgeving besmet is (geweest)  met het coronavirus.

--> To do: nog uitwerken: CoronaInfectionOther_1-8 - In onderstaande grafiek is te zien welke relatie deze personen tot de respondent hadden (grafiek nog maken) (zie figuur \@ref(fig:coronainfectionother)). 

```{r coronainfectionother, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Relatie geÃ¯nfecteerde personen tot de respondent"}
# Create the plot#LUKT NOG NIET
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("CoronaInfectionOther_1", 
                        "CoronaInfectionOther_2", 
                        "CoronaInfectionOther_3", 
                        "CoronaInfectionOther_4",
                        "CoronaInfectionOther_5",
                        "CoronaInfectionOther_6",
                        "CoronaInfectionOther_7",
                        "CoronaInfectionOther_8")
graph_questionlabels = c("Ja, mijn partner", 
                         "Ja, een of meerdere\n familieleden", 
                         "Ja, een of meerdere\n vrienden", 
                         "Ja, een of meerdere\n collegaâs/studiegenoten",
                         "Ja, een of meerdere\n kennissen",
                         "Anders",
                         "Nee, niemand",
                         "Weet ik niet/wil ik\n niet zeggen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

```

#### Corona risicoperceptie en ernst
Uit gedragswetenschappelijke literatuur is bekend dat gepercipieerde ernst en vatbaarheid voor een ziekte een rol kan spelen in de acceptatie van gezondheidsadviezen. Ongeveer de helft van de steekproef acht zichzelf vatbaar voor het coronavirus: `r round((nrow(filter(data, (HBM_PSus_self1 == 'Helemaal mee eens'| HBM_PSus_self1 == 'Mee eens'| HBM_PSus_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% gaf aan het eens te zijn met de stelling dat men risico loopt op een besmetting in de komende twee maanden (zie figuur \@ref(fig:riskperception)). Daarnaast was een vergelijkbaar percentage (`r round((nrow(filter(data, (HBM_PSus_other2 == 'Helemaal mee eens'| HBM_PSus_other2 == 'Mee eens'| HBM_PSus_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) het in meer of mindere mate eens met de stelling dat de kans groot is om een ander te besmetten indien men zelf besmet raakt.

De gepercipieerde ernst lag hoger onder de respondenten, met name de ernst van het besmetten van anderen (`r round((nrow(filter(data, (HBM_PSev_other2 == 'Helemaal mee eens'| HBM_PSev_other2 == 'Mee eens'| HBM_PSev_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Daarnaast vindt `r round((nrow(filter(data, (HBM_PSev_self1 == 'Helemaal mee eens'| HBM_PSev_self1 == 'Mee eens'| HBM_PSev_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% het erg om zelf besmet te raken met het coronavirus.

```{r riskperception, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - hele populatie", tab.cap="Waargenomen ernst en vatbaarheid - hele populatie"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende \n twee maanden risico op een \n besmetting met het coronavirus", 
                         "Als ik besmet raak \n is de kans  groot dat ik anderen \n zal besmetten", 
                         "Ik vind het erg om \n besmet te raken", 
                         "Ik vind het erg als ik \n andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Naleven algemene gedragsregels
In kaart is gebracht in hoeverre de respondenten zich in de afgelopen 2 maanden aan een aantal van de algemene gedragsregels hebben gehouden (zie figuur \@ref(fig:behavioradhgenmeasures)). `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd'| Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'))) /nrow(data))*100, digits = 1)`% Gaf aan, regelmatig, vaak of altijd handen te wassen. Ongeveer de helft van de respondenten (`r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| Behavior_AdherenceGeneralMeasures_distance == 'Soms'))) /nrow(data))*100, digits = 1)`%) gaf aan nooit, zelden of soms op minder dan 1,5 afstand van mensen buiten het huishouden te zijn geweest. Tot slot gaf `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'))) /nrow(data))*100, digits = 1)`% aan nooit, zelden of soms op een plek te zijn geweest waar anderhalve meter afstand houden eigenlijk niet mogelijk was. 

```{r behavioradhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels", tab.cap="Naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance", 
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces")
graph_questionlabels = c("... hebt u uw handen gewassen?", 
                         "... bent u minder dan op 1,5m\n afstand geweest van mensen\n buiten uw huishouden?", 
                         "... bent u op een plek geweest\n waar het eigenlijk te druk was\n om 1,5m afstand te houden?"); 
plot_title = "In de afgelopen 2 maanden, hoe vaak..."

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van alle respondenten gaf `r round(nrow(filter(data, Corona_complaints == "Ja"))/nrow(data)*100, digits =1)`% aan klachten te hebben gehad die passen bij het coronavirus in de afgelopen twee maanden. Onderstaande grafiek (figuur \@ref(fig:coronacomplaintsquarantaine)) laat zien in hoeverre deze respondenten in quarantaine bleven: in totaal gaf `r round((nrow(filter(data, Corona_complaints == "Ja" & (Behavior_AdherenceGeneralMeasures_quarantaine == 'Nooit'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Zelden'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Soms'))) /nrow(filter(data, Corona_complaints == "Ja")))*100, digits = 1)`% nooit, zelden of soms naar buiten te zijn geweest met klachten.

```{r coronacomplaintsquarantaine, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels bij klachten"}


# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Bent u, toen u\n deze klachten\n had, naar buiten\n geweest?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Nooit", "Zelden", "Soms", "Regelmatig", "Vaak", "Meestal", "Altijd"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Corona_complaints=='Ja'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = graph_answercategories # For some reason, in this case it does not need to be reverted.
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot naleving algemene gedragsregels
Er is gevraagd naar in welke mate men van plan is om zich de komende twee maanden te houden aan een aantal van de algemene gedragsregels. Het percentage respondenten dat aangeeft de intentie te hebben om zich aan de voorgestelde gedragsregels te houden ligt hoog (handen regelmatig wassen: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; afstand houden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; drukke plekken vermijden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven bij klachten: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Onderstaande figuur geeft de intenties weer (figuur \@ref(fig:intentionadhgenmeasures)).

```{r intentionadhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot naleving algemene gedragsregels", tab.cap="Intentie tot naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance", 
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces", 
                        "Intention_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van\n mensen buiten mijn huishouden", 
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last\n heb van klachten die\n passen bij het coronavirus"); 
plot_title = "Ik ben van plan om de komende 2 maanden..."
# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Algemene opvattingen over het coronavirus

#### ComplottheorieÃ«n
Om in kaart te brengen in hoeverre complottheorieÃ«n een rol spelen is gevraagd of men dacht dat onderstaande stellingen waar of onwaar zijn (zie figuur \@ref(fig:complot)). Van de respondenten beoordeelt `r round((nrow(filter(data, (Beliefs_Conspiracy1 == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% de stelling 'Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt' met misschien waar of zeker waar. Een kleiner percentage beoordeelt de stelling 'De uitbraak van het coronavirus heeft te maken met het 5G netwerk' als misschien waar of zeker waar (`r round((nrow(filter(data, (Beliefs_Conspiracy2 == 'Zeker waar'| Beliefs_Conspiracy2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r complot, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof in complottheorien", tab.cap="Geloof in complottheorien"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een \n biologisch wapen dat in een \n laboratorium is gemaakt", 
                         "De uitbraak van het \n coronavirus heeft te maken met \n (de aanleg van) het 5G netwerk"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

#table(data$Beliefs_Conspiracy1)

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Vertrouwen in aanpak van de overheid
Respondenten zijn verdeeld wat betreft vertrouwen in de overheid met betrekking tot de aanpak van de coronacrisis (zie figuur \@ref(fig:trustgovernment)). Ongeveeer de helft is het eens met de stelling stelling 'Ik heb vertrouwen in de manier waarop de Nederlandse ovreheid probeert het coronavirus onder controle te houden' (`r round((nrow(filter(data, (Beliefs_TrustGovernment == 'Helemaal mee eens'| Beliefs_TrustGovernment == 'Mee eens'| Beliefs_TrustGovernment == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r trustgovernment, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Vertrouwen in de Nederlandse overheid"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")
graph_questionlabels = c("Ik heb vertrouwen\n in de manier waarop\n de Nederlandse overheid\n probeert het coronavirus\n onder controle te houden"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

## Bekendheid en gebruik
### Bekendheid met CoronaMelder
In de vragenlijst werd gevraagd hoe bekend men (voor het openen van de vragenlijst) was met de CoronaMelder app. In totaal gaf `r round(((nrow(filter(data, Awareness == 'Heel erg bekend')) + nrow(filter(data, Awareness == 'Bekend')) + nrow(filter(data, Awareness == 'Redelijk bekend'))+ nrow(filter(data, Awareness == 'Een beetje bekend')))/nrow(data)*100), digits = 1)`% aan in meer of mindere mate bekend te zijn met de CoronaMelder (zie figuur \@ref(fig:awareness)). Ruim 1 op de 10 (`r round(nrow(filter(data, Awareness == 'Niet bekend'))/nrow(data)*100, digits = 1)`%) gaf aan niet bekend te zijn met de CoronaMelder.   

--> To do: Verdere uitplitsingen. 

```{r awareness, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Bekendheid met CoronaMelder", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}
# Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
ggplot(data=data, aes(x = Awareness)) + theme_bw() + xlab(paste(names(table(data$Awareness)))) + ylab(" ") + xlab("Hoe bekend bent u met\n de CoronaMelder?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))
```

```{r awarenesslftd, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per leeftijdscategorie"}
# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per geslacht"}
# Awareness op gender
ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

### Gebruik CoronaMelder
Van alle respondenten gaf `r round(nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))/nrow(data)*100, digits = 1)`% aan dat hij/zij de CoronaMelder op dit moment gebruikt en `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))/nrow(data)*100, digits = 1)`% geeft aan de CoronaMelder niet te gebruiken. Slechts `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))/nrow(data)*100, digits = 1)`% gaf aan de CoronaMelder in het verleden gebruikt te hebben maar op dit moment niet meer. 

#### Vergelijking gebruikers en niet gebruikers
Om inzicht te krijgen in welke factoren (demografisch, persoonlijk, sociaal, omgevingsfactoren) worden gebruikers vergeleken met niet gebruikers. 
--> To do: verdere uitsplitsingen en bijbehorende statistische tests.   

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende \n twee maanden risico op een \n besmetting met het coronavirus", 
                         "Als ik besmet raak \n is de kans  groot dat ik anderen \n zal besmetten", 
                         "Ik vind het erg om \n besmet te raken", 
                         "Ik vind het erg als ik \n andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r perceivedsuscsev, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende \n twee maanden risico op een \n besmetting met het coronavirus", 
                         "Als ik besmet raak \n is de kans  groot dat ik anderen \n zal besmetten", 
                         "Ik vind het erg om \n besmet te raken", 
                         "Ik vind het erg als ik \n andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Intentie tot (blijvend) gebruik CoronaMelder
Er werd gevraagd of de respondenten de intentie hadden om de CoronaMelder de komende twee maanden te (blijven) gebruiken. Van de respondenten die de CoronaMelder app nooit hebben gebruikt, gaf `r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens'| BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan van plan te zijn om de CoronaMelder te gebruiken in de komende twee maanden (zie figuur \@ref(fig:intentiontousenonusers)). Ongeveer een kwart geeft aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1a_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%). Bijna 6 op de 10 respondenten (`r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee oneens'| BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) geeft aan niet van plan te zijn de CoronaMelder te gaan gebruiken.  

```{r intentiontousenonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1a_UTAUT", 
                        "BI2a_UTAUT")
graph_questionlabels = c("Ik ben van plan de \n CoronaMelder in de komende  \n 2 maanden te gebruiken", 
                         "Het is waarschijnlijk dat \nik de CoronaMelder in de komende  \n 2 maanden zal gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van de respondenten die de CoronaMelder op dit moment al gebruiken, gaf een overgrote meerderheid (`r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) aan van plan te zijn de CoronaMelder te blijven gebruiken in de komende 2 maanden (zie figuur \@ref(fig:intentiontousecurrentusers)). Een kleine hoeveelheid respondenten gaf aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) Slechts `r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% gaf aan niet van plan te zijn de CoronaMelder te blijven gebruiken. 

```{r intentiontousecurrentusers, eval=FALSE, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1b_UTAUT", 
                        "BI2b_UTAUT")
graph_questionlabels = c("Ik ben van plan de \n CoronaMelder in de komende  \n 2 maanden te blijven gebruiken", 
                         "Het is waarschijnlijk dat \nik de CoronaMelder de komende  \n 2 maanden zal blijven gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r IntentieHL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
#df_PSev %>% filter(!is.na(Value))

data_nona1a <- data[!is.na(data$BI1a_UTAUT),]
data_nona1b <- data[!is.na(data$BI1b_UTAUT),]

#ggplot(data=data_nona1a, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
#ggplot(data=data_nona1b, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

rm(data_nona1a)
rm(data_nona1b)
```

--> To do: verdere opsplitsing Gedrag en intentie:   
1) Vergelijking gebruikers vs niet gebruikers (deze wave laten we de groep die het gebruikt hebben maar nu niet meer buiten beschouwing agz dat er nog vrij weinig zijn)  
2) Van de niet gebruikers: vergelijking van intentie eens (beetjemee eens + eens + helemaal mee eens), neutraal, oneens (beetje mee oneens + eens + helemaal oneens).   
--> Vergelijk deze groepen op alle variabelen in:   
Demografische factoren, gezondheidsmotivatie en algemene opvattingen over het coronavirus (variabelen 2.1).   
Deze opsplitsing naar demografie geeft inzicht in welke groepen vd bevolking de CoronaMelder meer of minder gebruikt wordt. De opsplitsing naar adherence en intentie tot adherence aan de andere maatregelen geeft inzicht in of de gebruikers van de CoronaMelder mensen zijn die zich sowieso al meer aan de maatregelen houden.


## Verklarende variabelen voor adoptie

--> To do: Opspliting verklarende variabelen: 
Allemaal opsplitsen naar 1) gebruikers vs niet gebruikers en 2) Van de niet gebruikers: vergelijking van eens, neutraal, oneens. In zijn totaliteit geeft deze sectie dan een beeld van wat de gebruikers onderscheid van de niet gebruikers, en welke beliefs met communicatie/campagnes veranderd kunnen worden bij de groep die de CoronaMelder niet gebruikt maar er neutraal tegenover staat (obv deze verklarende variabelen)


### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
In kaart is gebracht in welke mate men denkt dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. In totaal gaf `r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan het eens te zijn met de stelling dat men door het gebruiken van de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. Daarnaast gaf `r round((nrow(filter(data, (PE2_UTAUT == 'Helemaal mee eens'| PE2_UTAUT == 'Mee eens'| PE2_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt en geeft `r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verwachte effeciviteit CoronaMelder", tab.cap="Verwachte effeciviteit CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te \n gebruiken help ik mee bij de \n bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig \n om ervoor te zorgen dat het \n coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om \nmensen met een kwetsbare \n gezondheid te beschermen") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er is ook gevraagd hoeveel procent van de Nederlandse bevolking volgens de respondent de CoronaMelder app zou moeten gebruiken om de verspreiding van het coronavirus tegen te gaan. De meeste respondenten (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%'))/nrow(data)*100, digits = 1)`%) dachten dat 76-90% van de Nederlandse bevolking de CoronaMelder moet gebruiken om de verspreiding van het coronavirus tegen te gaan. In totaal dacht `r round(((nrow(filter(data, Beliefs_ResponseefficasyOther == '51-75%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '91-100%')))/nrow(data)*100), digits = 1)`% van de respondenten dat meer dan 50% van de Nederlandse bevolking de CoronaMelder app moet gebruiken om effectief te zijn. Het aandeel respondenten dat aan gaf niet te weten hoeveel mensen de CoronaMelder app zouden moeten gebruiken is `r round(nrow(filter(data, Beliefs_ResponseefficasyOther == 'Weet ik niet'))/nrow(data)*100, digits = 1)`%. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan"}
# Beliefs_ResponseefficasyOther
ggplot(data=data, aes(x = Beliefs_ResponseefficasyOther)) + theme_bw() + xlab(paste(names(table(data$Beliefs_ResponseefficasyOther)))) + ylab(" ") + xlab("Hoeveel procent van de Nederlandse bevolking\n zou volgens u de CoronaMelder moeten gebruiken\n om de verspreiding van het coronavirus tegen te gaan?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))

```

#### Per (potentiÃ«le) gebruikersgroep
```{r, echo=FALSE}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te \n gebruiken help ik mee bij de \n bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig \n om ervoor te zorgen dat het \n coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om \nmensen met een kwetsbare \n gezondheid te beschermen") 

# Split by 6 user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))
colnames(data_grouptable) <- c("variable", usergroup_variablenames)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,1] = graph_variablenames[idx]
  
  # Current user of app, would keep using
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))
  
  # Current user of app, neutral
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & BI1b_UTAUT == 'Neutraal' & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))
  
  # Current user of app, would stop using
  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))
  
  # Current non-user, intend to start using
  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & (BI1a_UTAUT == 'Helemaal mee eens' | BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))
  
  # Current non-user, neutral
  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & BI1a_UTAUT == 'Neutraal' & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))  
  
  # Current non-user, no intention to start using
  data_grouptable[idx,7] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx])) == 'Helemaal mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Mee eens' | eval(parse(text=graph_variablenames[idx])) == 'Een beetje mee eens') & (BI1a_UTAUT == 'Helemaal mee oneens' | BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
#ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", ifelse(user_totals[1,colname]==0,0,eval(parse(text=colname))/user_totals[1,colname]*100)), "%)"))
    
    # Add total to footer
    #tablecolumn = paste("data_table$", colname)
    #totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

### Vertrouwen in adequaatheid techniek
COMMENT: ik snap deze vraag niet helemaal? Dit meet toch niet perse vertrouwen in de adequaatheid, maar is meer een feitelijke kennis-check? 

In de vragenlijst werd gepeild in welke mate men vertrouwen heeft in de adequaatheid van de techniek. Het overgrote deel van de respondenten antwoordde 'zeker waar' of 'misschien waar' op de stelling 'De techniek (Bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is' (`r round((nrow(filter(data, (Beliefs_technologyperformance == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 


```{r technology, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Vertrouwen in techniek", tab.cap="Vertrouwen in techniek"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
                        
graph_questionlabels = c("De techniek (bluetooth) die\n wordt gebruikt in de CoronaMelder\n geeft aan wie er in de buurt\n is geweest van\n een persoon die besmet is"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Maatschappelijke gevolgen gebruik CoronaMelder
Aan de respondenten werd gevraagd in hoeverre zij dachten dat gebruik van de CoronaMelder de Nederlandse economie helpt. Ongeveer Ã©Ã©n op de drie respondenten heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen (`r round((nrow(filter(data, (Beliefs_benefiteconomic == 'Helemaal mee eens'| Beliefs_benefiteconomic == 'Mee eens'| Beliefs_benefiteconomic == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r beneficteconomic, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Overtuiging dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder \n helpt de Nederlandse economie"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Verwachte gebruiksvriendelijkheid en zelfeffectiviteit
EE1a_UTAUT
EE2a_UTAUT
EE1b_UTAUT
EE2b_UTAUT
HBM_selfefficacy_CoronaMelder

```{r effortexpectancynonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1b_UTAUT", 
                        "EE2b_UTAUT")
graph_questionlabels = c("Ik denk dat het mij veel\n tijd en energie kost\n om de CoronaMelder\n te gebruiken", 
                         "Ik denk dat de\n CoronaMelder\n makkelijk te\n gebruiken is"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r effortexpectancyusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment gebruiken", tab.cap="Eigen effectiviteit onder bij respondenten die de CoronaMelder op dit moment gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1a_UTAUT", 
                        "EE2a_UTAUT")
graph_questionlabels = c("Het kost(te) mij veel\n tijd en energie\n om de CoronaMelder\n te gebruiken", 
                         "De CoronaMelder is\n makkelijk te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```

```{r selfefficacyCM, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Zelfeffectiviteit om CoronaMelder te installeren"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_CoronaMelder")
graph_questionlabels = c("Ik ben in \n staat om de\n CoronaMelder\n te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + theme(plot.title = element_text(size=11))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



### Technologie gerelateerde belemmeringen
Vanuit het UTAUT is bekend dat technologie gerelateerde belemmeringen een rol kunnen spelen in de adoptie van nieuwe technologie. 

```{r , echo=FALSE, fig.width=7, fig.height=2, fig.cap="Technologie gerelateerde belemmeringen", tab.cap="Technologie gerelateerde belemmeringen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT")
graph_questionlabels = c("Ik heb een smartphone tot\n mijn beschikking met\n toegang tot het internet\n waarmee ik de\n CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische)\n kennis om de CoronaMelder\n te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik
Belangrijke variabelen uit het UTAUT en het HBM zijn de verwachte nadelen van het gebruik en de mate waarin iemand een verplichting voelt om de techniek te gebruiken. 

```{r Motivationsbarriersvoluntariness, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik", tab.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder", 
                        "Beliefs_voluntariness")
graph_questionlabels = c("Het heeft voor mij\n persoonlijke voordelen om\n de CoronaMelder te\n gebruiken",
                         "Het heeft voor mij\n persoonlijke nadelen om\n de CoronaMelder te\n gebruiken", 
                         "Ik voel me verplicht\n om de CoronaMelder\n te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Affectieve reacties
In kaart is gebracht in welke mate de CoronaMelder in het algemeen en meer specifiek het ontvangen van een melding een emotionele reaktie opwekt. 

```{r Affective, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Affectieve reacties", tab.cap="Affectieve reacties"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")
graph_questionlabels = c("Ik vind de\n CoronaMelder eng", 
                         "Ik zou angstig\n worden als ik een\n melding ontvang van\n de CoronaMelder"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



### Sociale invloeden
Om de sociale invloeden in kaart te brengen is gevraagd naar descriptieve en injunctieve normen en is gevraagd om een indicatie te geven van welk percentage van de Nederlandse bevolking de CoronaMelder gebruikt. Opvallend is dat een relatief laag percentage mensen het eens is met de stelling dat veel mensen in hun omgeving de CoronaMelder gebruiken. Dit kan liggen aan het feit dat gebruik van de CoronaMelder redelijk onzichtbaar is (in tegenstelling tot het gebruik van bijvoorbeeld een mondkapje).   

Beliefs_AppAdoption

```{r Beliefsappadoption, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage bevolking dat volgens de respondent de CoronaMelder gebruikt"}
ggplot(data=data, aes(x = Beliefs_AppAdoption)) + theme_bw() + xlab(paste(names(table(data$Beliefs_AppAdoption)))) + ylab(" ") + xlab("Hoeveel procent van de\n Nederlandse bevolking denkt u\n dat de CoronaMelder gebruikt?") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(,axis.title=element_text(size=10))

```


```{r Socialnormscivicduty, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Sociale normen", tab.cap="Sociale normen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn\n omgeving gebruiken\n de CoronaMelder", 
                         "Mensen in mijn directe\n omgeving vinden\n dat ik de CoronaMelder\n moet gebruiken",
                         "Het gebruiken van de\n CoronaMelder maakt je\n een goede burger"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Sociale invloeden naar gebruikersstatus


### Privacy en dataveiligheid 
Beliefs_datasafety
Beliefs_locationmonitoring
Beliefs_identitymonitoring

```{r privacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Privacy overtuigingen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring")
graph_questionlabels = c("Alle informatie die\n ik geef in de\n CoronaMelder wordt\n vertrouwelijk behandeld",
                         "De CoronaMelder houdt\n mijn locatie bij", 
                         "De CoronaMelder slaat\n mijn naam of\n persoonsgegevens op"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


## Effecten
### Meldingen en reacties op adviezen gegeven in de melding

```{r adherenceappnotification, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Thuisblijven na melding"}

#KLOPT NOG NIET!!! NAs staan er nog in
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Notification_behavior_quarantaine")
graph_questionlabels = c("Bent u nadat u\n deze melding(en)\n kreeg zo lang\n thuisgebleven als\n de melding adviseert?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


#### Ontvangen meldingen en opvolging van de adviezen
In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens Ã©Ã©n melding gehad vanuit de app; dat is `r round(nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))/nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer')))*100, digits = 1)`%.Vanwege dit lage aantal zijn de vervolgvragen voor deelnemers die een melding hebben ontvangen (opvolging van de adviezen, etc.) niet verder bekeken. 

#### Intentie tot opvolgen adviezen gegeven in de melding
Aan de respondenten is gevraagd in hoeverre zij de intentie hebben om, na ontvangen van een melding, zich te houden aan de adviezen die in een melding van de CoronaMelder worden gegeven. Om dit te onderzoeken werd proefpersonen twee sitaties voorgelegd (situatie waarin men wel of geen symptomen had) en een screenshot van de melding getoond. Een belangrijke noot bij deze resultaten is dat ten tijde van deze enquete het testbeleid zo was dat men na het ontvangen van een melding alleen kon laten testen indien symptomen aawezig waren (in de appendix kan de vragenlijst inclusief screenshot van melding gevonden worden). 

``` {r adherencenotificationsnosymp, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen", tab.cap="Intentie tot opvolgen adviezen zonder symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest\n aan te vragen", 
                         "Thuisblijven zo lang\n de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r adherencenotificationssympt, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen met symptomen", tab.cap="Intentie tot opvolgen adviezen met symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest\n aan te vragen", 
                         "Thuisblijven zo lang\n de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidig gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. 
``` {r adherencenotificationsnosympcurrentusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest\n aan te vragen", 
                         "Thuisblijven zo lang\n de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r adherencenotificationssymptcurrentusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest\n aan te vragen", 
                         "Thuisblijven zo lang\n de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Verklarende factoren opvolging adviezen gegeven in melding
##### Eigen effectiviteit opvolging adviezen
Om de eigen effectiviteit in kaart te brengen werd gevraagd in welke mate men dacht in staat te zijn om de adviezen uit de melding op te volgen. 

```{r adherencenotificationsselfefficacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit om adviezen op te volgen", tab.cap="Eigen effectiviteit om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_Test", 
                        "HBM_selfefficacy_Quarantaine", 
                        "HBM_selfefficacy_Visits",
                        "HBM_selfefficacy_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven\n als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Ik ben in staat om...") + theme(plot.title = element_text(size=11))

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen
Uit het Health Belief Model is bekend dat de mate waarin men verwacht dat een gedrag persoonlijke voor- of nadelen heeft een rol kan spelen in de adoptie van het gedrag. Voor een aantal gedragingen omtrent de opvolging van adviezen zijn deze voor- en nadelen uitgevraagd. Het blijkt dat ongeveer de helft van de respondenten deze persoonlijke voordelen inziet (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Helemaal mee eens'| HBM_perceivedbenefits_Test == 'Mee eens'| HBM_perceivedbenefits_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Helemaal mee eens'| HBM_perceivedbenefits_Quarantaine == 'Mee eens'| HBM_perceivedbenefits_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Helemaal mee eens'| HBM_perceivedbenefits_Visits == 'Mee eens'| HBM_perceivedbenefits_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Helemaal mee eens'| HBM_perceivedbenefits_GP == 'Mee eens'| HBM_perceivedbenefits_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zie figuur \@ref(fig:HBMbenefits). Een aanzienlijke groep staat neutraal tegenover de voordelen om adviezen op te volgen ((bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%.

```{r HBMbenefits, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voordelen om adviezen op te volgen", tab.cap="Persoonlijke voordelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_Test", 
                        "HBM_perceivedbenefits_Quarantaine", 
                        "HBM_perceivedbenefits_Visits",
                        "HBM_perceivedbenefits_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven\n als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke voordelen om...") + theme(plot.title = element_text(size=11))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Ook met betrekking tot persoonlijke nadelen van het opvolgen van de adviezen blijkt een groot aandeel neutraal te zijn (bellen voor een test: `r round((nrow(filter(data, (HBM_barriers_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_barriers_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_barriers_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Er zit variatie in de mate waarin men het eens is met de stellingen of bepaalde acties persoonlijke nadelen hebben. Het percentage mensen dat het eens is met nadelige gevolgen is het grootst voor thuisblijven (`r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Helemaal mee eens'| HBM_barriers_Quarantaine == 'Mee eens'| HBM_barriers_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en het niet kunnen ontvangen van bezoek (`r round((nrow(filter(data, (HBM_barriers_Visits == 'Helemaal mee eens'| HBM_barriers_Visits == 'Mee eens'| HBM_barriers_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Het bellen voor een test (`r round((nrow(filter(data, (HBM_barriers_Test == 'Helemaal mee eens'| HBM_barriers_Test == 'Mee eens'| HBM_barriers_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts bellen (`r round((nrow(filter(data, (HBM_barriers_GP == 'Helemaal mee eens'| HBM_barriers_GP == 'Mee eens'| HBM_barriers_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) wordt als minder nadelig gezien (zie figuur \@ref(fig:HBMbarriers)).


```{r HBMbarriers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke nadelen om adviezen op te volgen", tab.cap="Persoonlijke nadelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_barriers_Test", 
                        "HBM_barriers_Quarantaine", 
                        "HBM_barriers_Visits",
                        "HBM_barriers_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven\n als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke nadelen om...") + theme(plot.title = element_text(size=11))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Intentie tot doorgeven GGD-sleutel na positieve test
Als iemand positief is getest op het coronavirus kan men dit daarna via de app laten weten door de GGD-sleutel door te geven aan de GGD medewerker. Dan waarschuwt de app weer mensen bij wie de positief gesteste persoon in de buurt is geweest. Van de respondenten heeft `r round((nrow(filter(data, (Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%  de intentie om de GGD-sleutel door te geven. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot doorgeven GGD-sleutel", tab.cap="Intentie tot doorgeven GGD-sleutel"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, \n ben ik van plan om dit door\n  te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Onbeoogde effecten: schijnveiligheid
Een gevoel van schijnveiligheid zou kunnen optreden bij de adoptie van de CoronaMelder, wat ervoor zou kunnen zorgen dat andere maatregelen minder nodig worden geacht. Uit de antwoorden op de stelling of men zich minder aan andere maatregelen kan houden bij het gebruik van de CoronaMelder, blijkt dat slechts een klein aandeel denkt dat dit het geval is. Het aandeel dat op deze vraag 'zeker waar' of 'misschien waar' antwoordt, is `r round((nrow(filter(data, (Beliefs_falsesecurity1 == 'Zeker waar'| Beliefs_falsesecurity1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%. Een iets groter percentage denkt dat de CoronaMelder ervoor zorgt dat je niet besmet kunt raken (`r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Zeker waar'| Beliefs_falsesecurity2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r falsesecurity, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Schijnveiligheid", tab.cap="Schijnveiligheid"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_falsesecurity1",
                        "Beliefs_falsesecurity2")
graph_questionlabels = c("Als ik de CoronaMelder\n gebruik, hoef ik me\n minder aan de andere\n maatregelen te houden",
                         "De CoronaMelder zorgt\n ervoor dat ik niet\n besmet raak met het\n coronavirus"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette) + scale_x_discrete(labels=graph_questionlabels) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
table_answercategories = rev(graph_answercategories)
data_table = data.frame(table_answercategories)

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Sort properly -- NOTE: does not work yet?
data_table$table_answercategories <- factor(data_table$table_answercategories,levels = rev(table_answercategories))

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```







\newpage
# Conclusie en aanbevelingen
\newpage
# Referenties
\newpage
# Bijlagen
## Vragenlijst wave 1












``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in Ã©Ã©n grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
#ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

